2/3
Image File Formats
Compressed v. Uncompressed
    Compressed
	Smaller
    	Processing involved in viewing/generating a file
    	EX)
	    jpg/jpeg
	    webp
	    png
	    gif

    Uncompressed
        Raw image data
        EX)
	    bmp
	    tiff
	    raw

Lossy v. Lossless
    Lossy
        Loses some original information
        EX)
	    jpg
    Lossless
        Retains all original information
	EX)
	    bmp
	    tiff
	    png

    Run-Length Encoding
        12 B --> GGGGGYYYRRRR
        6  B --> 5G3Y4R

	6  B --> GYRYGR
	12 B --> 1G1Y1R1Y1G1R

Raster v. Vector
    Raster
        Represented as a grid of pixels
    Vector
        Represented as a list of drawing instructions


2/4
Netppm
    .ppm
    
    P3                         }
    XRES YRES MAX_COLOR_VALUE  } Header
    R G B R G B R G B......

    * All white space is equivalent.

    P3
    10 10 255
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0

    Press ctrl-c ctrlc to switch from text to image in emacs

    display pic.ppm
    convert pic.ppm pic.png

2/5
Bresenham's Line Algorithm
y = m * x + b
y = (changeY/changeX) * x + b
(changeX) * y = (changeY) * x + (changeX) * b
0 = (changeY) * x - (changeX) * y + (changeX) * b

A = changeY
B = -changeX
C = changeX * b

0 = Ax + By + C

For now, limit lines to octant I. Therefore, 0 < m < 1.

f(x, y) = Ax + By + C

  0: (x, y) is on the line.
< 0: (x, y) is above the line.
> 0: (x, y) is below the line.

2 options:
1: (x + 1, y + 1)
2: (x + 1, y)
Check to see which magnitude is smaller.
DONT DO THIS - test the midpoint instead.
Midpoint -- if midpoint is above the line, draw the lower pixel
	    if midpoint is below the line, draw the higher pixel.
	    (x + 1, y + 1/2)

2/9

A = changeX
B = -changeX
C = changeX * b

f(x + 1, y + 1/2)
= 0 --> midpoint is on the line --> You can draw either pixel.
< 0 --> midpoint is above the line --> Draw the bottom pixel (x + 1, y)
> 0 --> midpoint is below the line --> Draw the upper pixel(x + 1, y + 1)

First Draft Algorithm
(x0, y0) --> (x1, y1)
x = x0, y = y0
while (x <= x1) {
  plot(x, y)
  delta = f(x + 1, y + 1/2) //You need to know A, B, and C
  if (d > 0) {
     y += 1;
  }
  x += 1;

Initial value of d:
d = (x0 + 1, y0 + 1/2)
d = A(x0 + 1) + B(y0 + 1/2) + C
d = Ax0 + A + By0 + B/2 + C
  = Ax0 + By0 + C + A + B/2
  = f(x0, y0) + A + B/2
  = 0 + A + B/2
  = A + B/2 --> Works because x0 y0 is used.

Second Draft Algorithm
(x0, y0) --> (x1, y1)
x = xn, y = yn
d = A + B/2
while (x <= x1) {
  plot(x, y)
  if (d > 0) {
     y += 1;
  }
  x += 1;
  d = f(x + 1, y + 1/2)

if d < 0			 
x -> x + 1, y -> y			 
f(x + 1, y)
d = A(x + 1) + By + C
d = Ax + A + By + C
d = Ax + By + C + A
d = f(x, y) + A
d = d + A because f(x, y) is previous d.

if d > 0
x -> x + 1, y -> y + 1			 
f(x + 1, y + 1)
d = A(x + 1) + B(y + 1) + C
d = Ax + A + By + B + C
d = Ax + By + C + A + B
d = f(x, y) + A + B
d = d + A + B because f(x, y) is previous d.

Third Draft Algorithm
(x0, y0) --> (x1, y1)
x = x0, y = y0
A = y1 - y0, B = -(x1 - x0)
d = A + B/2
while (x <= x1) {
  plot(x, y)
  if (d > 0) {
     y += 1;
     d += B;
  }
  x += 1;
  d += A;

2/10
 d = A + B
2d = 2A + B

Now, instead of d, use...
2d = 2d + 2A
2d = 2d + 2A + 2B

Final Algorithm
(x0, y0) --> (x1, y1)
x = x0, y = y0
A = y1 - y0, B = -(x1 - x0)
d = 2A + B
while (x <= x1) {
  plot(x, y)
  if (d > 0) {
     y += 1;
     d += 2B;
  }
  x += 1;
  d += 2A;

Octant 2:
Slope > 1
Now, new values will be either...
  (x, y + 1) or
  (x + 1, y + 1)

  Now, midpoint we want to check is (x + 1/2, y + 1).

  Initial d:
  d = (x0 + 1/2, y0 + 1)
  d = A(x0 + 1) + B(y0 + 1/2) + C
  d = Ax0 + A/2 + By0 + B + C
    = Ax0 + By0 + C + A + B
    = f(x0, y0) + A/2 + B
    = 0 + A/2 + B
    = A/2 + B --> Works because x0 y0 is used.
  2d = A + 2B

  If Ax + By + C = ...
  0, point on the line
  <0, point left of line
  >0, point right of line

  Final Algorithm
  (x0, y0) --> (x1, y1)
  x = x0, y = y0
  A = y1 - y0, B = -(x1 - x0)
  d = A + 2B  //midpoint is different
  while (y <= y1) { //change in Y will indicate reaching final point
    plot(x, y)
    if (d < 0) { //d < 0, point left of line, so draw line up and right.
      x += 1; //increment to go right
      d += 2A; //increment A instead of B
    }
    y += 1; //increment to go up
    d += 2B; //Increment B instead of A

For octant V, you can simply switch x0 and y0 and x1 and y1, and now
it is just like drawing in octant I. DO NOT SWITCH ONLY ONE, SWAP BOTH.

Octant VIII:
-1 < m < 0
Now, new values will be either...
  (x + 1, y) or
  (x + 1, y - 1)
