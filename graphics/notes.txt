2/3
Image File Formats
Compressed v. Uncompressed
    Compressed
	Smaller
    	Processing involved in viewing/generating a file
    	EX)
	    jpg/jpeg
	    webp
	    png
	    gif

    Uncompressed
        Raw image data
        EX)
	    bmp
	    tiff
	    raw

Lossy v. Lossless
    Lossy
        Loses some original information
        EX)
	    jpg
    Lossless
        Retains all original information
	EX)
	    bmp
	    tiff
	    png

    Run-Length Encoding
        12 B --> GGGGGYYYRRRR
        6  B --> 5G3Y4R

	6  B --> GYRYGR
	12 B --> 1G1Y1R1Y1G1R

Raster v. Vector
    Raster
        Represented as a grid of pixels
    Vector
        Represented as a list of drawing instructions


2/4
Netppm
    .ppm
    
    P3                         }
    XRES YRES MAX_COLOR_VALUE  } Header
    R G B R G B R G B......

    * All white space is equivalent.

    P3
    10 10 255
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0
    255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0 255 255 0

    Press ctrl-c ctrlc to switch from text to image in emacs

    display pic.ppm
    convert pic.ppm pic.png

2/5
Bresenham's Line Algorithm
y = m * x + b
y = (changeY/changeX) * x + b
(changeX) * y = (changeY) * x + (changeX) * b
0 = (changeY) * x - (changeX) * y + (changeX) * b

A = changeY
B = -changeX
C = changeX * b

0 = Ax + By + C

For now, limit lines to octant I. Therefore, 0 < m < 1.

f(x, y) = Ax + By + C

  0: (x, y) is on the line.
< 0: (x, y) is above the line.
> 0: (x, y) is below the line.

2 options:
1: (x + 1, y + 1)
2: (x + 1, y)
Check to see which magnitude is smaller.
DONT DO THIS - test the midpoint instead.
Midpoint -- if midpoint is above the line, draw the lower pixel
	    if midpoint is below the line, draw the higher pixel.
	    (x + 1, y + 1/2)

2/9

A = changeX
B = -changeX
C = changeX * b

f(x + 1, y + 1/2)
= 0 --> midpoint is on the line --> You can draw either pixel.
< 0 --> midpoint is above the line --> Draw the bottom pixel (x + 1, y)
> 0 --> midpoint is below the line --> Draw the upper pixel(x + 1, y + 1)

First Draft Algorithm
(x0, y0) --> (x1, y1)
x = x0, y = y0
while (x <= x1) {
  plot(x, y)
  delta = f(x + 1, y + 1/2) //You need to know A, B, and C
  if (d > 0) {
     y += 1;
  }
  x += 1;

Initial value of d:
d = (x0 + 1, y0 + 1/2)
d = A(x0 + 1) + B(y0 + 1/2) + C
d = Ax0 + A + By0 + B/2 + C
  = Ax0 + By0 + C + A + B/2
  = f(x0, y0) + A + B/2
  = 0 + A + B/2
  = A + B/2 --> Works because x0 y0 is used.

Second Draft Algorithm
(x0, y0) --> (x1, y1)
x = xn, y = yn
d = A + B/2
while (x <= x1) {
  plot(x, y)
  if (d > 0) {
     y += 1;
  }
  x += 1;
  d = f(x + 1, y + 1/2)

if d < 0			 
x -> x + 1, y -> y			 
f(x + 1, y)
d = A(x + 1) + By + C
d = Ax + A + By + C
d = Ax + By + C + A
d = f(x, y) + A
d = d + A because f(x, y) is previous d.

if d > 0
x -> x + 1, y -> y + 1			 
f(x + 1, y + 1)
d = A(x + 1) + B(y + 1) + C
d = Ax + A + By + B + C
d = Ax + By + C + A + B
d = f(x, y) + A + B
d = d + A + B because f(x, y) is previous d.

Third Draft Algorithm
(x0, y0) --> (x1, y1)
x = x0, y = y0
A = y1 - y0, B = -(x1 - x0)
d = A + B/2
while (x <= x1) {
  plot(x, y)
  if (d > 0) {
     y += 1;
     d += B;
  }
  x += 1;
  d += A;

2/10
 d = A + B
2d = 2A + B

Now, instead of d, use...
2d = 2d + 2A
2d = 2d + 2A + 2B

Final Algorithm
(x0, y0) --> (x1, y1)
x = x0, y = y0
A = y1 - y0, B = -(x1 - x0)
d = 2A + B
while (x <= x1) {
  plot(x, y)
  if (d > 0) {
     y += 1;
     d += 2B;
  }
  x += 1;
  d += 2A;

Octant 2:
Slope > 1
Now, new values will be either...
  (x, y + 1) or
  (x + 1, y + 1)

  Now, midpoint we want to check is (x + 1/2, y + 1).

  Initial d:
  d = (x0 + 1/2, y0 + 1)
  d = A(x0 + 1) + B(y0 + 1/2) + C
  d = Ax0 + A/2 + By0 + B + C
    = Ax0 + By0 + C + A + B
    = f(x0, y0) + A/2 + B
    = 0 + A/2 + B
    = A/2 + B --> Works because x0 y0 is used.
  2d = A + 2B

  If Ax + By + C = ...
  0, point on the line
  <0, point left of line
  >0, point right of line

  Final Algorithm
  (x0, y0) --> (x1, y1)
  x = x0, y = y0
  A = y1 - y0, B = -(x1 - x0)
  d = A + 2B  //midpoint is different
  while (y <= y1) { //change in Y will indicate reaching final point
    plot(x, y)
    if (d < 0) { //d < 0, point left of line, so draw line up and right.
      x += 1; //increment to go right
      d += 2A; //increment A instead of B
    }
    y += 1; //increment to go up
    d += 2B; //Increment B instead of A

For octant V, you can simply switch x0 and y0 and x1 and y1, and now
it is just like drawing in octant I. DO NOT SWITCH ONLY ONE, SWAP BOTH.

Octant VIII:
-1 < m < 0
Now, new values will be either...
  (x + 1, y) or
  (x + 1, y - 1)

2/22
Using Matrices:

  Point Matrix:
  [P0 P1 P2 P3 P4 P5 P6]

  while (i < points.length - 1) {
    draw_line(points[i], points[i + 1]);
    i++;
  }

  Not what we want.

  1. Shape Matrix:
     [[P0, P1, P2], [P3, P4, P5, P6]]
  
  2. [P0, P1, P2, P0, 0, P3, P4, P5, P6, P3, 0]

  ** 3. Edge Matrix:
       [P0, P1, P1, P2, P2, P0,...]

  4. Have 2 Matrices:
       Point Matrix:
       [P0, P1, P2, P3]
       Connection Matrix:
         0  1  2  3
       0 T  T  T  F
       1 T  T  T  F
       2 T  T  T  F
       3 F  F  F  T
  
  [P0, P1, P1, P2, P2, P0, P3, P4]

  [X0, X1, X1, X2, X2, X0, X3, X4]
  [Y0, Y1, Y1, Y2, Y2, Y0, Y3, Y4]
  [Z0, Z1, Z1, Z2, Z2, Z0, Z3, Z4]
  [ 1,  1,  1,  1,  1,  1,  1,  1]

  edges = new_matrix()
  add_edge(edges, P0, P1)
  ...
  draw_lines(edges)

2/23
Matrix Math
  Scalar Multiplication
  Matrix Multiplication
  Matrix Multiplication Identity

Scalar Multiplication
  S * [A B] = [SA SB]
      [C D] = {SC SD]

Matrix Multiplication
  M0 * M1 != M1 * M0
  Number of columns in M0 must equal the number of rows in M1
    A x B * B x C ==> inner numbers must be equal.
      	      	  ==> Outer numbers represent the result matrix size. (A x C)
		      A rows, C columns
		      
  [a b c] * [1] = [1a+2b+3c]
    1x3     [2]      1x1
    	    [3]
	    3x1

               0 1           0         1
  0 [a b c] * [1 4] = 0 [1a+2b+3c  4a+5b+6c] 
  1 [d e f]   [2 5]   1 [1d+2e+3f  4d+5e+6f]
  2 [g h i]   [3 6]   2 [1g+2h+3i  4g+5e+6i]
    3x3        3x2              3x2

Matrix Multiplicative Identity
  All diagonal values are 1, others are zero.
  Always square.

  [1 0 0 0] * [a]
  [0 1 0 0]   [b]
  [0 0 1 0]   [c]
  [0 0 0 1]   [d]
     4x4      4x1

Graphics Matrices
  Scaling
    (x, y, z) -------> (ax, by, cz)
    	      S(a,b,c)
	
    [a 0 0 0] * [x] = [ax]
    [0 b 0 0]   [y]   [by]
    [0 0 c 0]   [z]   [cz]
    [0 0 0 1]   [1]   [1 ]
       4x4      4x1   4x1

       4x4 * 4xN = 4xN ==> Keeps the same number of points.

2/24
Scaling
  (x, y, z) --------> (ax, by, cz)
      	    s(a,b,c)

     x y z
    [a 0 0 0] * [x] = [ax]
    [0 b 0 0]   [y]   [by]
    [0 0 c 0]   [z]   [cz]
    [0 0 0 1]   [1]   [1 ]
       4x4      4x1   4x1

       4x4 * 4xN = 4xN ==> Keeps the same number of points.

Translating
  (x, y, z) --------> (x + a, y + b, z + c)
      	    T(a,b,c)

    [1 0 0 a] * [x] = [x + a]
    [0 1 0 b]   [y]   [y + b]
    [0 0 1 c]   [z]   [z + c]
    [0 0 0 1]   [1]   [1]

Rotation
  (x, y, z) -------> (x cos (Θ) - y sin (Θ), y cos (Θ) + x sin (Θ), z)
      	    R(z, Θ)

  The axis you are turning around is fixed.

  Z axis rotation:
    x = r cos Φ  xr = r cos (Φ + Θ)
    y = r sin Θ       r cos (Φ) cos (Θ) - r sin (Φ) sin (Θ)
        	      x cos (Θ) - y sin (Θ)

    x = r cos Φ  yr = r sin (Φ + Θ)
    y = r sin Θ       r sin (Φ) cos (Θ) + r cos (Φ) sin (Θ)
        	      y cos (Θ) + x sin (Θ)

    [cosΘ -sinΘ 0   0] * [x] = [xcosΘ - ycosΘ]
    [sinΘ cosΘ  0   0]   [y]   [ycosΘ + xsinΘ]
    [0    0     1   0]   [z]   [z]
    [0    0     0   1]   [1]   [1]



2/25
  X axis rotation:
    (x, y, z) -------> (x, y cos (Θ) - z sin (Θ), z cos (Θ) + y sin (Θ))
    	      R(x, Θ)
  In this case, y is on the x axis, z is on the y axis

    [1	0      0    0] * [x] = [x]
    [0  cosΘ  -sinΘ 0]   [y]   [ycosΘ - zsinΘ]
    [0  sinΘ   cosΘ 0]   [z]   [zcosΘ + ysinΘ]
    [0  0      0    1]   [1]   [1]

  Y axis rotation:
    (x, y, z) -------> (x cos (Θ) - z sin (Θ), y , z cos (Θ) + x sin (Θ))
    	      R(Y, Θ)
  In this case, x is on the x axis, z is on the y axis

    [cosΘ 0     -sinΘ 0] * [x] = [xcosΘ - zsinΘ]
    [0    1      0    0]   [y]   [y]
    [sinΘ 0      cosΘ 0]   [z]   [xsinΘ + zcosΘ]
    [0    0      0    1]   [1]   [1]

Applying transformations:
  E0: Edge Matrix
  T: Translation Matrix
  S: Scale Matrix
  R: Rotation Matrix

  Affine transformation: Preserves the number of vertices and order of points.

  T * E0 --> You do this so you preserve the 4 x N edge matrix.

  T * E0 = E1 : Translated
  S * E1 = E2 : Translated --> Scaled
  R * E2 = E3 : Translated --> Scaled --> Rotated

  E3 = R * E2
       	   S * E1
	       T * E0
  E4 = R * S * T * E0 --> You can put this all in one line.

  Matrix Multiplication is associative but not commutative.
       A * (B * C) = (A * B) * C

  E4 = (R * S * T) * E0 --> By grouping the transformations together, you can create
       	      	     	    a "master transformation" matrix, then multiply it by
			    the edge matrix. You do this because E0 can be large.
			    *** E0 is translated, scaled, THEN rotated ***
			    *** Work from inside to out ***

  When resetting your transformation matrix, you set it to the identity matrix.


3/7
Parametric Equations
  x = f(t)
  y = g(t)

  EX) f(t) = t^2 + 2t + 2
      g(t) = 1 - t/(2^t)

    t: 0 --> 1

  Line: (x0, y0) --> (x1, y1)
  f(t) = x0 + t(deltaX)
  g(t) = y0 + t(deltaY)

  double x0, y0, x, y, t;
  x0 = param_x(0);
  y0 = param_y(0);

double param_x(double t) {
  return t * XRES;
}

double param_y(double t) {
  return 50 * sin(2 * M_PI * t) + 250;
}

  double step = 0.01

  for (t = step; t <= 1; t+= step) {
    x = param_x(t)
    y = param_y(t)
    add_edge(edges, x0, y0, 0, x, y, 0);
    x0 = x;
    y0 = y;
  }

  color c;
  c.red = 255;
  c.blue = 255;
  c.green = 0;
  clear_screen(s);
  draw_lines(edges, s, c);
  display(screen);
}

Circle:
  x = rcos(t) + cx
  y = rsin(t) + cy

double param_x(double t) {
  return 100 * cos(2 * M_PI * t) + 250;
}

double param_y(double t) {
  return 100 * sin(2 * M_PI * t) + 250;
}

by changing the step, you will make different regular polygons.
  
