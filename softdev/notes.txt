if __name__ == "__main__":
   print "LOADING AS MAIN"
else:
   print "LOADING AS MODULE"

git checkout --> takes away changes until last commit

virtualenv pd7en
cd bin
source activate
pip install flask

9/22
Make default app.py

Route	     call this function
/home	     home()
/about	     about()

app.py
from flask import Flask

app = Flask(__name__), render_template

@app.route("/about")
def about():
    return render_template("about.html")

@app.route("/about")
def about():
    page = """
    <h1>About</h1>
<hr>
<ol>
<li>Fred Flintstone</li>
<li>Mr. T</li>
<li>The Hulk</li>
</ol>
"""
    return page

@app.route("/home") --> if you go to path home, run this function)
@app.route("/")
def home():
    return "<h1>Hello World</h1>"

@app.route("/lucky")
def lucky():
    import random
    number = random.randrange(1, 100)
    return "Lucky Number: %d"%(number)

if __name__ == "__main__":
    app.debug = True;
    app.run(host = '0.0.0.0', port = 8000)
    #127.0.0.1 --> private address to use
    

You would run this program on localhost:8000/home
""" -->multiline string
"""

Web templates are used to create the HTML.

def lucky():
    import random
    n = random.randrange(1, 100)
    return render_template("lucky.html", number = n)

lucky.html file:
<!DOCTYPE HTML>
<h1>Lucky Number</h1>
<h2>Your Lucky Number is {{number}}</h2>
 -n will replace number in the HTML file.

Dictionaries:
    d = {}
    d[10] = "hello"
    d['one'] = 12345
    d['two'] = "Something"
    can also be initialized with values
    d = {'one': hello, 'two': 12345}
    Mutable

{10:'hello', 'one': 12345, 'two' = "Something"}
    d.has_key() - checks if a key exists
    d.keys() - returns all the keys

You can access the variables using d[key] or d.key
You can also print out the dictionary itself
Now, instead of using {{variable}}, you will be able to use {{d[variable]}} in
the template.

Lists:
    a = [10, 20, 'thirty', 40, 'fifty']
    You can return char in string by a[index] or multiple by a[startind:endind]

You can also run loops
    Ex)<ul>
	 {% for item in l %}
    	 <li>{{item}}</li>
	 {% endfor %}
       </ul>

@app.route("/profile/<lastname>")
def profile(lastname=""):

================================================================================
9/28
If you make a directory called static, you can load things from that folder
   ex) <img src="/static/thiuffy.png>

GET Request
    <form>
	name: <input type="text" name = "name">
	age: <input type="text" name = "age">
	<input type="submit" name="button" value="ok">
	<input type="submit" name="button" value="cancel">
    </form>

import request
def index():
    print request.__dict__ //prints out dictionary of request
    print request.args //returns an immutable dictionary with all the args.
{% for a in args %}
   
{% endfor %}

   request.args.get(index)

   However, GET is insecure and may run out of space.
   Most web api's usually use GET

POST Request
    <form method="POST">>
        name: <input type="text" name = "name">
	password: <input type="text" name = "pasword">
	<input type="submit" name="button" value="login">
	<input type="submit" name="button" value="cancel">
    </form> 

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method=="GET":
        return render_template("login.html")
    else:
	//print request.args
	
	<h1>Logging in</h1>
//GET goes into args index, POST goes into form index
      ex) print request.form['username']
      ex) print request.form['username']
      ex) print request.form['username']
      
To authenticate, you can make a module called utils.py and put authenticate
function in it.
