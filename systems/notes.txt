9/11 - Aim: C what I did there?
Do Now:
From Yesterday:
     4) Figure out what gcc does
     	man gcc
     5) Copy woohoo.c from your home directory to a /code/ directory on homer
        scp woohoo.c jason.shin@homer.stuy.edu:/code
	     ^source      ^destination          ^remote directory
	*Colon is necessary. If you leave out path, file goes to home directory
	*Remote to remote or Remote to current also work

Today:
     List all the Java primitive variable types
     int      32 bit integer
     float    floating point
     boolean  True/False
     char     character
     short    16 bit integer
     double   64 bit floating point
     long     64 bit integer
     byte     8 bit integer
     *bool and byte are not in C

     Last Class Today:
     	  1 student chosen at random everyday. That evening, the person will be
	  responsible for posting notes to Piazza page. Tag the note as "last 
	  class today".
	  	Title the note LCT <MM/DD WEEKDAY>
		For example, LCT 9/10 Thursday

		Also include at the end of the note a link to an interesting 
		piece of tech news.

9/12 - Aim: Variables are the spice of life.
Do Now: What is the smallest variable type that could be used to store the
   following values (using standard sizes)?
   byte (8-bit): 
   	-128 to 127 (or 2^7 to 2^7 - 1)
   short (16-bit):
   	-2^15 to 2^15 - 1
   int (16-bit):
        -2^31 to 2^31 - 1
   long (64-bit):
   	-2^63 to 2^63 - 1
   1) 5 --> byte
   2) -30,000 --> short
   3) 255 --> short
   4) 5,000,000,000 --> long

C Primitive Variable Types
   All C primitives are numeric.
   The only difference is floating point vs. integer and size of variable.
   Size can be platform dependent.
   	sizeof(<TYPE>) can be used to find the size in bytes.
	ex. sizeof(int)
   
   Type		Standard Size (in bytes)
   int		4
   short	2
   long		8
   float	4
   double 	8
   char		1

   All boolean values are numbers
       0 ==> false
       anything else ==> true
       YOU WILL ALL MAKE THIS MISTAKE:
       	   if (x = 6) {...}
       *The assignment value will return the value you are assigning.

9/17
Aim: Always read the fine print.
Do Now: Open up your editor of choice (emacs)
   	Write a basic "Hello World" program in java.

Data Types and Variables
     
     Character literals are single characters inside ''
     	  ex. 'a', '*' ...
     
     String literals exists, even though there is no String data type.
     	  ex. "hello", "you smell"
     
     Variables cannot be declared inside for loops statements, but they can be
     initialized.
     
     Any variable type can be declared an "unsigned" variable
     This signifies the variable will never be negative.
     	  The lower bound of of any unsigned variable is 0
	  The upper bound will be greater than the signed version
	  ex. unsigned char x;
	      0 <= x <= 255

     int main() {    --> You don't need the arguments in main
     	 return 0;   --> Return 0 if everything went ok
     }

     gcc hello.c     --> Generates a program called a.out
     ./a.out	     --> You need the ./ to run it
     gcc hello.c -o greeter
     ./greeter

9/18 - Aim: A vast array of possibilities.
SOTD: Superstitious - Stevie Wonder
Do Now: How do you declare/use arrays in java?
   datatype[] = new datatype[size];
   
   PATH - Location of known executable files
   echo $PATH - Prints out PATH variable in terminal
   which emacs - Prints out path where emacs is
   
   Errors: segmentation fault or a bus fault

   C does not provide any extra functions. You need to include the libraries 
   in order to use the functions in those libraries.
   
   Usual libraries to include
   #include <stdio.h>
   #include <stdlib.h>
   	<> indicates the library is in one of the normal places where C
   	libraries are.

   #include "mylib.h"
   	"" are used for libraries that you wrote.

   printf("bob = %f\n", bob);
   	%f is the placeholder for where bob will appear.
	
   printf() --> function for printing to the screen.
   	f stands for format

	If you want to print variables, you must include formatting placeholders
	in the string argument
	   int i = 5
	   printf("i is %d", i)

	   Type	     Formatting Character
	   int	     %d
	   long	     %ld
	   float     %f
	   double    %lf
	   	     %0
	   char	     %c
	   char array %s
	   pointer    %p

9/22 - Aim: What's the point of it all?
SOTD: Hunger Strike - Temple of the Dog

Memory Management
    Memory allocation either happens at compile time or at run time (dynamic).
    	Ex) using "new" in java was dynamic memory allocation
	Compile Time --> Stack memory
	Run Time --> Heap memory
    Compiler Allocated Memory
    	Packaged with the binary of the program
	*There is no standard default value*
	Variables and arrays are allocated here
	    Ex. float a    int b[5] --> Arrays in C is stack based and cannot
	    	      	       	    	be resized.
*Test your work on lab computers --> They are the middle ground
    Arrays
	Are not dynamic
	Must have a fixed size
	There is no length function
	There is no boundary checking
	    Ex:    bob fred a[0]  a[1]  a[2]  a[3]
	    	   [ ]  [ ]  [ ]   [ ]   [ ] ...
		   992  996  1000

9/22 - Aim: Ok, now we're really going to get to the point
SOTD: Here Comes the Helicopter
   bob fred a[0]  a[1]  a[2]  a[3]
   [7] [86]  [ ]   [ ]   [ ] ...
   992  996  1000
   
   int a[5];
   int fred;
   fred (996) = 86;
   int *pfred

   Variable names are placeholders for memory addresses.

   Pointers - Now the fun really starts
   	Variable that is designed to store memory addresses (think references
	in java)

   & is used to get the memory address of a variable.
     	Ex) &fred
   * is used to declare a variable as a pointer type
        Ex) int *p, double *q, char *r, ...

	  pfred     fred
	  [996] --> [86]
       	  2020	    996
	  
	  *pfred = &fred

   32 Bit Processor vs 64 Bit Processor
      	32 bit can read in 32 bits of memory and 64 bit can read in 64 bits of 
	memory
	32 bit system can only have 2^32 bits of memory, or 4 GB of RAM
	64 bit system can have 2^64 bits of memory

9/28 - Aim: Ok, now we're really goinng to get to the point.
SOTD: Lump - The Presidents of the United States of America

Do Now:
   1) Declare int, double, and char variables.
        int a;
	double b;
	char c;
   2) Declare int, double, and char pointers.
      	int *pa;
	double *pb;
	char *pc;
   3) Initialize each pointer to the address of the corresponding variable.
	pa = &a;
	pb = &b;
	pc = &c;
   4) Print out the pointer's value for each (as an unsigned long)
        printf( pa = %lu\n", *pa);
	printf( pb = %lu\n", *pb);     
	printf( pc = %lu\n", *pc);
   5) 

   Adding 1 to a pointer type will increase the memory address by the amount of 
   bytes of that type.
   Adding a void pointer type adds 1 to memory address
   Pointers - The fun really starts
   
   Variables designed to store memory addresses (think references in java)

       & is used to get the address of the variable
       
       * is used to declare a variable as a pointer type
       	 ex. int *p, double *q, char *r
	 
       Node n;
        n
       [0] --> null

       * is also used as the de-reference operator
            It accesses the value at the memory location stored in a pointer

       All pointer variable types are the same size
       
       Pointer Arithmetic
            int *p = &1;
	    int *c = &i;
	    
	    p++; //will add 4 to p
	    c++; //will add 1 to p

       Array variabes are immutable pointers.

       Pointers can be assigned to array variables
       int ray[5];
       int *rp = ray;

       ray[3] <===> *(rp + 3)
       rp and ray point to ray[0]
       [ ] [ ] [42] [ ]
        0   1   2    3
       a[i] notation is shorthand for *(a+1)
       in fact...
       	  a[i] <===> *(a + 1)
	  i[a] <===> *(i + a)

SOTD: In The Meantime - Spacehog
9/29 - Aim: Time to stop stringing you along.

float fray[5];
float *fp = fray[0]; --> Will try to point to memory address 2.3 (DNE)
      	    	     	 Valid, but you don't mean this.

float *fp = fray; 
      fray--> will point to 824
      	      will print out 824
      *fp --> 2.3, derefernece operator

fray--> [2.3] [ 2 ] [81.7] [.21] [ 5 ]
	 824   828   832    

Value of ray and rp are both the same memory address because they point to the
same thing.
*ray and *rp will dereference what is there and are the same. *ray = ray[0].
&ray and %rp can be different. Usually different from the value of ray and rp
themselves, but can sometimes be the same. 

fp + 2 --> will return 832
*fp + 2 --> will return 4.3 
*(fp + 2) --> will dereference mem address 832 --> 81.7

ray[2] <==> *(ray + 2) <==> *(2 + ray) <==> 2[ray]
Braket notation simply means add these two numbers.

rp++; --> modifying a pointer variable is fine.
ray++; --> ERROR: cannot increment the array variable pointer.

C Strings (ctrings)
    Strings are character arrays that end with a null character (either '' or 0
    or '\0')

    ['c'] ['a'] ['t'] [ 0 ]

    The terminating null character is a convention, string functions will not 
    work without it.

    The following are valid ways to declare strings:
    	char s[256];
	     Normal array declaraction, allocates 256 bytes, nothing is set
	     automatically. Can return junk.
    	char s[256] = "Imagine";
	     Allocates 256 bytes, puts "Imagine" in the first 7 bytes AND adds 
	     a null at the 8th byte. It may still cause a problem if array size
	     is not large enough.
	char s[] = "Tuesday"
	     Allocates 8 bytes, puts "Tuesday" in the first 7 bytes AND adds a
	     null at the 8th bytes.
    *Only time you can directly declare a string to the same char array 
     variable.

SOTD: One Headlight - The Wallflowers
Aim: How to write functioning code

Do Now: Write a c program that does the following
   1) Create a string and set it to some value
   2) Write code to find the length of the string and then print it. (Do not
      write a function for this.)

      char *s = "Mankind";
      Allocates 8 bytes, puts "Mankind" in the first 7 bytes AND adds a null
      at the 8th byte. s is a pointer variable instead of an array.
      *You can now move the pointer of the string. You cannot do that with the
       first 3 ways.

   You can only assign strings with = at declaration.
   char s[] = "zero"; //ok
   s = "seven"; //not ok!

   char *word = "cat";
   char *up = "dog";

   up = "cat"; //Not valid, up will want a single unsigned interger, 
      	       	 NOT another string.
   up = word; //up will now point to "cat". However, we now have a piece of 
      	      //memory that we will not be able to access.
	      //In order to use it, we need to release the memory

int main() {
  char s[] = "RandomStringLOL";
  char *p = s;
  int size = 0;
  /*
  while (*p) {    //--> This works because anything other than 0 is true.
    p++;
    size++;
  }
  */

  while (*p++) { //--> will derederence then add 1
    size++;
  }
  printf("Length of *%s* = %d\n", s, size);
  return 0;
}

C is a procedural function. Order that the functions appear in is important.
  You can make a function header.
      ex) int len(char *s);

SOTD: Tom Sawyer - Rush
Aim: How to write functioning code.
Functions: a brief interlude:
  All C functions are "pass by value"
      A parameter is a copy of the variable passed into the function. The
      original variable is not touched.
      
  ex) void foo(char *s, int i);
      int x = 5;
      char *w = "cool";
      foo(w, x);

       x    w
      [5] [8010]
            '-->[c][o][o][l][0]

      You can change what w points to, but you cannot change its value

  You can put your headers in a header file
  file - stringy.h
  int len(char *s);
  
  Then, in stringy.c, you can
  #include "stringy.h"

Back to Ctrings
     string.h
	C library that includes useful string functions
	All the functions 

	int strcomp( char *s1, char *s2 )
	    Returns 0 if s1 and s2 are identical
	    Returns positive if s1 is greater than s2
	    Returns negative number is s1 is less than s2
	char * strcpy (char *dest, char *source)
	    C
	char * strcat (char *s1, char *s2)
	Appends all the characters i[ 
	   returns s1
	strncat( char s1, char s2, int )
           appends at most n chars from s2 into s1

SOTD: Fake Plastic Trees - Radiohead
Aim: Make it so
char *s1 = "Hello";
char *s2 = "Hello";
char s3[] = "Hello";

"Hello" --> Immutable because it is a string literal
C does not want extra memory. s1, s2, and s3 all point to the same piece
of memory for "Hello"
s1 and s2 are pointers. They will actually POINT to the SAME immutable string
"Hello".
When you declare an array, it will give you a new piece of memory with "Hello"
in it, so you can change it
When including a header file for a library you created for a different main
method, it will return an error.
To get around this, compile them at the same time
gcc main.c stringy.c --> Two main functions! Returns an error.
Just comment out main function in stringy.c, allowing main function in  main.c to run.
Having no main functions is also a problem.

SOTD: Rearviewmirror - Pearl Jam
Aim: Make it so

Separate Compilation

    You can combine mutiple C files into a C program by incuding them all in one
    gcc command.
    	ex.
	    gcc test.c string.c foo.c woohoo.c
    You cannot have duplicate function or global variable names across these
    files. This includes the main() function.

    gcc --> Creates an executable file by looking for methods in headers and
    linking them to functions in the standard path. You need to specify where
    the methods in the header function are if they are not in the standard path.
    Will find the main function and link all the functions called in main and
    put them into the executable file.
    If you have multiple main methods, comment one out.

    gcc -c
    	Will compile a c file into a .o file, it is not a fully functional
	program, but it is compiled code. Do this to compile a .c file that does
	not contain a main() function. Will not create an executable file
	
	You can now compile main.c, and then combine with dwstring.o
	gcc main.c dwstring.o

    	__________________________
	V	      |		  V
    dwstring.h    dwstring.c    main.c    
    		      ^	^_______  ^
		      |         | |
		  dwstring.o <---a.out

    Dependency - files that need to be changed because of another changed file.

    Make
	Create compiling instructions and setup dependencies
	Standard name for the file is makefile
	syntax:
	    <TARGET>: <DEPENDENCIES>
	    TAB<RULES>

    makefile
    a.out: dwstring.o main.c
    	    gcc dwstring.o main.o

    dwstring.o: dwstring.c dwstring.h
    	    gcc -c dwstring.c

    main.o: main.c dwstring.h
    	    gcc -c main.o
    First target is always run. The subsequent files will also be checked if
    there are other dependencies. Will recursively check.

SOTD: Breaking the Girl - Red Hot Chili Peppers
Aim: If you can't (al)locate your memory, then... I forget

Dependencies:
dwstring.c    dwstring.h    main.c
        \      /        \   /
       dwstring.o       main.o
       	     \____  _____/
		 a.out

In order to create a.out, you need to combine dwstring.o and main.o
In order to create dwstring.o, you need to combine  dwstring.c and dwstring.h
In order to create main.o, you need to combine dwstring.h and main.c
Think about what files you need in order to create the file you are thinking of
For any particular .o file, you will usually only need one .c file.
Make a dependency chart to put togeter a decent makefile.

make will run a makefile named makefile.
If make is run again without being modified, nothing will happen

    makefile
    all: dwstring.o main.c
    	    gcc -o string_test dwstring.o main.o

    dwstring.o: dwstring.c dwstring.h
    	    gcc -c dwstring.c

    main.o: main.c dwstring.h
    	    gcc -c main.o
    clean:
	    rm *.o
	    rm *~
    run:
	    ./string_test

    First target is always run. The subsequent files will also be checked if
    there are other dependencies. Will recursively check through the
    dependencies.

If you use a name, it will always run.
EX) make all --> will run gcc dwstring.o main.o

You can also specify the target
EX) make dwstring.o

Compares the timestamps of the dependencies and the timestamp of the target.
If timestamp dependency > timestamp target, it will run the rules.

'clean' will never happen untill it is called upon because it has no
dependencies.

'make run' will run the program.

All future assignments will involve a make file.
Don't upload the executable/.o files

Dynamic Memory Allocation:
    malloc(int x)
        Allocates x bytes of memory (from the heap)

	Returns the address at the beginning of the allocation

	Returns a void *, always typecast to the correct pointer type.

        int *p;
	p = (int *)malloc(5 * sizeof(int));
	Will allocate 20 bytes of memory.

	Similar to 'new' in java

    calloc(int n, int x);
        Allocates n * x bytes of memory

	Ensures that each bit is set to 0.

	Works like malloc in all other ways

	int *p;
	p = (int *)calloc(5, sizeof(int));

    realloc(void *p, int x)
    	Changes the amount of memory allocated to a given block.
    
	p must be a pointer to the beginning of an allocated block of memory, 
	but it does not have to be the original pointer
   
	x is the amount of memory reallocated, NOT amount adding/taking away.
 
	If x is smaller than the original size of the allocations, the extra 
	bytes will be released.

    	int *p;
   	p = (int *)malloc(20);
    	p = (int *)realloc(p, 40);

10/9
SOTD: Papa's Got a Brand New Bag - James Brown
Aim: Always structure your code well.

Dynamic Memory Allocation
    Normal memory allocation happens on the stack.
    
    Stack memory gets released as functions pop off.

    Dynamic memory is located on the heap, it persists even after the funtion
    that created it pops off the stack.

    You must manually release dynamically allocated memory from the heap.

    As long a program is running, any memory associated with it will be there.
    When a program ends, memory associated with the program is released.


    free
	Releases dynamically allocated memory.
	
	Takes one parameter, a pointer to the beginning of a dynamically
	allocated block of memory.
	
	Every call to malloc/calloc should have a corresponding call to free.

	int *p;
	p = (int *)malloc(20);
	free(p);

    When you try to change the pointer to the allocated memory, you get an error
    Error is descriptiive because we are requesting memory through the OS.
    Having another pointer point to the beginning is fine.

    Typedef
	Provide a new name for an existing type.
	
	typedef <realtype> <new name>;
	typedef float bubbles;

	Often put in a header files.
	
    	ex: typedef unsigned int size_t;
            size_t x = 139 //x is really an unsigned int

    Struct
	A collection of values in a single data type
	struct {int a; char x;} s;	
	
	To access the data in the struct, you would use the . notation
	ex: struct {int a; char c} s;
	    struct {int a; char c} t;
	    
	    s.a = 97;
	    t.c = '@';

	struct foo {int a; char c};
	struct foo s;
	struct foo t;

	foo is like header, it represents {int a; char c;}
	
	typedef struct n {int a; struct n *next;} node;	
	foo t;
	
	foo *t;
	t = (foo *)malloc( sizeof(foo) );
	
	(*t).a = 97;
	t->a

SOTD: Low Rider - War
Aim: Zelda's in trouble, get Link!
Do Now: What's wrong with this function?
   	(Assume node has been declared correctly)

node * insert_front(node * n, int i) {
     node new;
     new.i = i;
     new.next = n;
     return &new;
}
new is part of stack memory, which would be popped off the stack after the
function called ends. In order to keep the value of node, you would need to
allocate memory on the heap.

It is acceptable to have your function headers lack names for your variables as
long as you have the type.

C - Always use lowercase letters, but separate words by underscores.
print_list - snakecase
printList - camelcase

library.h
#include "link_list.h"
void print_artist(song.node *);

main.c
#include "link_list.h" --> You don't need this because library.h already 
	                   includes it. BUT it does not show that linked_list.h
			   is included if you take it out.
#include "library.h"

# --> pre-processor instruction

#define --> Allows you to create a constant in your code
#define foo 27

#ifndef --> Stands for "if not defined"
#ifndef foo 
#def foo
     <code> 
#endif

#ifndef LINK_LIST_H
#define LINK_LINK_H
typedef struct n {
...
} song_node;
...
#endif
Good convention to do this for all header files to remove conflicts

SOTD: Wheels - Cake
Aim : File this under useful information.
Do Now: What are the different kinds of file permissions?
   	Read	     	 Write	       Execute
Also, who has these permissions?

dev - filled with files with devices.
random in dev --> seeds a random num  generator with random bits in memory.
sranddev() --> seeds using random in dev

File Permissions
     3 Kinds of Permissions
         read, write, execute

     Permissions can be represented as 3 digit binary numbers, or 1 digit octal
     numbers:

     R	    W	   E
     1	    0	   0 => 4 (base 8)
     0	    1 	   0 => 2 (base 8)
     0	    0	   1 => 1 (base 8)
     1	    1	   1 => 7 (base 8)

     There are 3 permission "areas"
     	 user, group, others --> Mutually exclusive sets

 	 each area can have its own permissions:
	 
	 644 => user: read + write, group: read, other: read

     To change the permissions -> chmod 600 foo.
     Owner of the file can ALWAYS  change the permissions of the file.

10/21
Note: Don't compile .h files!
SOTD: Everything - MrNorth
Aim: Opening up a whole new world of possibilities.

     Owner of the file can ALWAYS  change the permissions of the file.

     chown - changes owner of the file.
     chgrp - changes the group of the file.

     File Table
     	 A list of all files used by a program while it is running.
	 
	 Contains basic information like the file's location and size.

	 The file table has a limited size, which is a power of 2 and commonly
	 256, getdtablesize() will return this value. (int) - in <unistd.h>

	 Each file is given an integer index, starting at 0, this is referred
	 to as the file descriptor.

     EX File Table:
         File Descriptor |   Name (path)  | Location | 
	 ---------------------------------------------
		0	 |     stdin	  |	     |
	     	1	 |     stdout	  |	     |
		2	 |     stderr	  |	     |
	 
	 There are 3 files that are always open in the table: 
	     0 or STDIN_FILENO: stdin
	     1 or STDOUT_FILENO: stdout
	     2 or STDERR_FILENO: stderr

open - <fcntl.h>
     Add a file to the file table and returns its file descriptor
     
     If open fails, -1 is returned, extra error information can be found in
     a variable called errno - You need to call <errno.h> to get this.
     
	errno is an int variable that can be found in <errno.h>, using strerror
	(in <string.h>) on errno will return a string description of the error

     open( <PATH>, <FLAGS>, <MODE> )
     
     mode
	Only used when creating a file. Set the new file's permissions using a 3
	digit octal #

	Octal number have a leading 0
	    0644, 0777
	    
     flags
	Determine what you plan to do with the file.
	
	Use the following constants:
	    O_RDONLY
	    O_WRONLY
	    O_RDWR
	    O_APPEND
	    O_TRUNC
	    O_CREAT
	    O_EXCL: When combined with O_CREAT, will return an error if the file
	    	    exists
	All numbers, powers of 2

10/22
SOTD: Fly Me To The Moon - Frank Sinatra
Aim: Read your writes!
     EXLC    TRUNC    CREAT    APPEND    RDWR    WRONLY    RDONLY
     0	     0	      1	       0	 0	 0	   0	--> CREAT
     1	     0	      0	       0	 0	 0	   0	--> EXLC
     0	     0	      0	       0	 0	 1	   0	--> WRONLy
     1	     0	      1	       0	 0	 1	   0	--> ALL OF THESE

     bitwise operators
         &: bitwise and
	 |: bitwise or
	 ~: bitwise not
	 ^: bitwise xor

	 logical operators work on each bit of a value
	 
	 char c = 13;	//00001101
	 char x = ~c; 	//11110010

	 Two's complement
	 
     flags
	 Each flag is a number, to combine flags we use bitwise or
	 
	 O_WRONLY = 1		00000001
	 O_APPEND = 8		00001000
	 O_WRONLY | O_APPEND = 	00001001

     close - <unisrd.h>
     	 Remove a file from the file table
	 
	 Returns a 0 if unsuccessful. Returns -1 amd sets errno if unsuccessful.
	 close( <FILE DESCRIPTOR> );

read - <unistd.h>
     Read in a data from a file

     read( <FILE DESCRIPTOR>, <BUFFER>, <AMOUNT> )
     read(fd, buffer, n)
     
     Read n bytes from the fd's file and put that data into buff.
     
     Returns the number of bytes actually read. Returns -1 and sets errno if
     unsuccessful.

     BUFFER must be a pointer, otherwise it cannot be modified.

write parameters are identical to read parameters.

10/26
SOTD: Crazy - Gnarls Barkley
Aim: Seek and ye shall find

int r
int *s

r (4 bytes)   s (8 bytes)
 [	]       [  0  ] --> [integer]

fd1 = open("goo", O_CREAT, 0666);

There is a umask() function that can shut off permissions
umask(0111); --> This would shut off execute.
default umask is (0022); --> Doesn't allow write and exec for group and others
if umask(0000); --> All permissions will be available.

lseek - <unistd.h>
      Set the current position in an open file
      
      lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )
      
      Offset - How many bytes to move the position by.
      Whence -
      	     Where to measure the offset by
		 
10/28
SOTD: For What It's Worth - Buffalo Springfield
Aim: I need information, stat!
Do Now:
   1) Make a directory
   2) Put a few files in that directory and maybe even a directory or two

   Metadata - Data about data. (i.e last modified, who created it, etc.)

   stat - <sys/stat.h>
       Get information about a file (metadata)
       stat( <PATH TO FILE>, <STAT BUFFER> )
       
       Not an opened file, you don't need a file descriptor
       
           struct stat sb;
      	   stat("foo", &sb);

       to look up man page, use man 2 stat.       

       stat buffer
       	   Must be a pointer to a struct stat
	   
	   All the file information gets put into the stat buffer
	   
	   Some of the fields in the struct stat:
	       st_size
	           file size in bytes
	       st_uid, st_gid
	       	   user id, group id
	       st_mode
	           file permissions    
  	       st_atime, st_mtime
	           last access, last modification
	       
		   These are struct time_t variables. We can use functions
		   in time.h to make sense of them
		   
		   ctime( <time_t *> )
		       returns the time as a string
		       
		   time( <time_t *> )
		       sets the parameter to the current time

SOTD: In the Waiting Line - Zero 7
Aim: Where do compsci priests live? - In directory!
   ctime( <TIME> )
       TIME is type time_t *
       returns the time as a string
       
   time( <TIME> )
       TIME is type time_t *
       sets the parameter to the current time

   Directories
       A *nix directory is a file coontaining the names of the files within 
       the directory along with basic information like file type.
	
       Moving files into/out of a directory means changing the directory file, 
       OBnot actually moving any data.

   opendir - <dirent.h>
       Open a directory file
       
       This will not change the current working directory, it only allows your
       program to read the contents of the directory file.

       opendir( <PATH> );
       
       Returns a pointer to a directory stream (DIR *)

   closedir - <dirent.h>
       Closes the directory stream and frees the pointer associated with it.
       
       closedir( <DIRECTORY STREAM> )
       
   readdir - <dirent.h>
       readdir( <DIRECTORY STREAM> )
       
       Returns a pointer to the next entry in a directory stream, or NULL if 
       all entries have already been returned.
       
       struct dirent - <sys/types.h>

           Directory struct that contains the information stored in a directory
	   file.
	   
	   Some of the data members
	   
		d_name: Name of a file
		d_type: File

    rewinddir - <dirent.h>
    
    Resets the directory stream to the beginning
    
    rewinddir( <DIRECTORY STREAM> )

10/30
SOTD: War Pigs - Black Sabbath
Aim: Puttin' in the puts.

Command line arguments:

    int main( int argc, char *argv[] )

    program name is considered the first command line argument
    
    argc
	number of command line arguments
    
    argv
	array of command line arguments (strings)

scanf - <stdio.h>
    
    scanf( <FORMAT STRING>, <VAR 1>, <VAR 2>, ... )
    
    Reads in data from stdin using the format string to determine types.
    
    Puts the data in each variable.
    
    Variables must be pointers.

    EX)
        int x;
	float y;
        scanf("%d %f", &x, &y);
	
    "Enter" flushes the buffer and sends the data to stdin.
    Good for short inputs, but generally don't use it.
    Returns the number of matched values
	
fgets - <stdio.h>

    Read in from a file stream and store it in a string.
    
    fgets( <DESTINATION>, <BYTES>, <FILE POINTER> )
    
 Say it aint so - Weezer
    Puts a terminating null in the last byte, and reads in the new line
    ("enter")
    
    fgets( s, n, f );
        Reads at most n-1 characters from file stream f and stores it in
	s.

    File pointer
    
        File * type, more complex than a file descriptor
	
	stdin is a FILE * variable
    

11/4
Aim: Are your processes running? - Then you should go out and catch them!
Do Now: Run the command ps in terminal. What do you see?

ps shows the current running processes running from the terminal
ps -ax shows all running processes (even those not from terminal)

Processes
    Every running program is a process. A process can create subprocesses
    but thse are no different from regular processes.
    
    A processor can handle one process per cycle (per core).
    "Multitasking" appears to happen because the processor switches
    between all the active processes quickly.

    pid
	Every process has a unique identifier called the pid.

	pid 1 is the init process

	Each entry in the /proc directory is a current pid

    getpid() <unistd.h>
    	returns the current process' pid
	
    getppid() - <unistd.h>
    	returns the current process' parent pid

    fork() - <unistd.h>
    	Creates a separate process based on the current one, the new
	process is called the child, the original is the parent.
	
	The child process is a duplicate of the parent process. All parts
	of the parent process are copied, including stack and heap memory
	and the file table.

	    A quick note on threads: A thread is a separate executable
	    entity similar to a child process, except a thread is not a
	    standalone process. It does not have its own memory space,
	    instead it shares its parent's memory. 

	In the child process, fork() returns 0, and in the parent 
	process, fork() returns the child's PID or -1 (errno).

	If a parent process ends before the child, the child's new parent
	pid is 1

11/5
SOTD: Us and Them - Pink Floyd
Aim: Go fork off (another process)

When we call fork, both the parent and the child process runs the program

sleep(int secs) --> delays code for secs seconds

	  bash
	   |
	   |__  
	      |	 fork()
	      | <-- ls
	      |
	   |
	   | <--bash returns when child finished

wait - <unistd.h>
     Stops a parent process from running until any child has provided
     status information to the parent (usually the child has exited).
     
     Returns the PID of the child that exited, or -1 (errno).
     
     Return value of status only has room for one byte.

     WEXITSTATUS(status); - Get the return value of child process.

11/10
SOTD: Losing My Religion - REM
Aim: Time to bring out the executioner

You can put a child's function in one file, the parent's function in another,
and then include them in the main file.

childs_play function returns 25, but the actual process returns 0, because
we are still in the main function

Instead, you can just return childs_play()

exit() - Takes 1 parameter, which is the return value of the process.
         Stops the program.
	 
waitpid( PID, &status, 0 ) - waits for a specific child process' PID.

11/11
SOTD: Burden in my Hand - Soundgarden
Aim: Invasion of the process snatchers.

waitpid - <unistd.h>
    Waits for a specific child
    waitpid(pid, status, options)
        pid
	    The pid of the specific child to look for
	    If -1, will wait for any child
	
	options
	    Can set other behavior for wait, if 0, will work normally.

The exec family - <unistd.h>
    There are a number of C functions that can be used to run other programs
    from within our own programs.
    
    Replaces the current process with the new program, any code after a call to
    an exec function will be ignored.

    execl
	execl( <PATH>, <COMMAND>, <ARGS>, NULL )

	PATH
	    The path to the program (ex: "/bin/ls")
	    You can't use '~' for the home directory in the code

    	COMMAND
	    The name of the program (ex: ls)
	    What you use to invoke ls
	
	ARGS
	    Each command line argument you wish to give the program
	    (ex: "-a", "-l")
	
    	The last argument must be NULL in order to tell execl that there are
	no more arguments

    Example
        execl("/bin/ls", "ls", "-a", "-l". NULL)
	
    execlp
	execlp( <PATH>, <COMMAND>, <ARGS>, NULL )
	
	Works like excel, except it uses the PATH environment variable for
	commands, so you can use "ls" as the PATH instead of "/bin/ls"
	
	execlp( "ls", "ls", "-a", "-l", NULL)
	You still need the "ls" twice.

    execvp
	execvp( <PATH>, <ARGUMENT ARRAY> )
	
	ARGUMENT ARRAY
	    Array of strings, with element 0 must be the name of the program to
	    be executed and the last element must be NULL.
	    
            Like execlp, the PATH argument will take the PATH environment into 
	    account.

11/12
SOTD: Sell Out - Reel Big Fish
Aim: Let's take this to delimit!

strsep - <string.h>

    Used for parsing a string with a common delimiter
    
    strsep( <SOURCE>, <DELIMITER> )
    
    Locates the first occurrence of the delimiter in a string and
    replaces that character with NULL

    Returns the beginning of the original string.
    Sets the source string to the string starting at 1 index past the
    location of the new NULL
    
    Since the source variable's value is changed, it must be a pointer
    to the string.
    
    char line[100] = "wow-this-is-cool";
    char *s1 = line;
    
    strsep( &s1, "-" )
        replaces the - after wow with NULL
	returns "wow"
	sets s1 to "this-is-cool"

	If you run strsep again, it will set s1 to is-cool, but there
	is not pointer to this


    Ex) char line[100] = "wow-this-is-cool"
    	char * ps[5] //An array of 5 char *
	char *sl, *s2
        line --> [w][o][w][-][t][h][i][s][-][i][s][-][c][o][o][l][NULL]
	
    After strsep() a bunch of times.
	[w][o][w][NULL][t][h][i][s][NULL][i][s][NULL][c][o][o][l][NULL]
	 ^		^		  ^	      ^
	 |   ___________|		  |	      |
	 |  |	__________________________|	      |
	 |  |  |   ___________________________________|
  	 |  |  |  |
    ps  [ ][ ][ ][ ][ ]

    If strsep reaches the end of the string without finding the
    delimiter, it will return null.

11/16
SOTD: Gimmie Shelter - The Rolling Stones
Aim: Redirection, how does it ... SQUIRREL

File Redirection
    Changing the usual input/output behavior of a program.
    
    Command line redirection
        >
	    Redirects stdout to a file.
	    Overwrutes the contents of the file
	    <COMMAND> > <FILE>
	    EX) ls > file_list.txt

	>>
	    Redirects stdout to a file
	    Appends instead of overwrites
	
	2>
	    Redirects stderr to a file
	    Overwrites the file (2>> appends)

	&>
	    Redirects stdout and stderr

	< 
	    Redirects stdin from a file
	    EX) ./exec < foo.txt
	    
	| ( pipe )
	    Redirects stdout from one command to stdin of the next

    Redirection in C programs
    
        dup2 - <unistd.h>
	    Redirect one file descriptor to another
	    dup2( fd1, fd2 )
	        Redirects fd2 to fd1
		Basically duplicates first file descriptor to the second

        dup - <unistd.h>
	    
	    x = dup(1);
	    dup2(3, 1);
	    dup2(4, 1);

11/17
Two commands you cannot fork or exec in order for the shell to work
    -cd
    -exit

chdir(<PATH>) --> will change directory if possible. Returns -1 and
	          errno will print.


11/30
SOTD: Billie Jean - Michael Jackson
Aim: Sending mixed signals

Signals
    Limited way of sending information to a process.

    kill
	Command line utility to send a signal to a process

	$ kill <PID>
	    Sends signal 15 (SIGTERM) to PID
	    
	    $ kill -<SIGNAL> <PID>
	    sends SIGNAL to PID

	    man 3 signal

    killall [-<SIGNAL>] <PROCESS>
        Sends SIGTERM (or SIGNAL if provided) to all processes
	with PROCESS as the name

Signal handling in C programs <signal.h>

    kill
        Send a signal to a process in a C program
	kill(<PID>, <SIGNAL>)
	Returns 0 on success or -1 (errno) on failure.

    sighandler
        To work with signals in a C program you must create a
	signal handling function.
	
	Some signals (like SIGKILL) cannot be caught.
	
	static void sighandler( int signo )
	
	Must be static, must be void, must take a single int
	parameter. Can be a different name.
	
	Has to be in the same file as the main method, not the 
	header files

12/1
SOTD: Say it aint so - Weezer
Aim: You want the signal? You can't handle the signal!

     signal( <SIGNUMBER>, sighandler )

     EX) signal( SIGINT, sighandler );

     This will not stop the program, because now we are deviating
     from the original behavior. At the end, we do exit(0) to
     actually stop the program.

     Kill is unhandleable.

     After you create the function, you attach the signals to it
     using the signal function.


Shared Memory - <sys/shm.h>, <sys/ipc.h>, <sys/types.h>
    A segment of heap memory that can be accessed by multiple
    processes
    
    Shared memory is accessable via some key that is known by
    any process that needs to access it.
    
    *** Shared memory does not get released when a program exits.
    
    5 shared memory operations:
        Creates the segment (happens once)
	Access the segment (happens once per process)
	Attach the segment to a variable (once per process)
	Detach the segment from a variable (once per process)
	Remove the segment (happens once)

    shmget
	Create or access a shared memory segment.

    	Returns a shared memory descriptor (similar idea to a file
	descriptor), or -1 if it fails.
	
	shmget( <KEY>, <SIZE>, <FLAGS> )
    	
	    key
		Unique integer identifier for the shared memory
		segment
	    size
		How much memory to request
	    flags
	        Includes permissions for the segment
		
		Combine with bitwise or
		
		IPC_CREAT: create the segment. If the segment is
			   new, it Will set value to all 0s
		IPC_EXCL: Fail if the segment already exists and
			  IPC_CREAT is on
	Ex) int sd;
	    sd = shmget( 24601, sizeof(int), 0644 | IPC_CREAT )

    shmat
        Attach a shared memory segment to a variable.	
	
	Returns a pointer to the segment, or -1 (errno)
	
	shmat( <DESCRIPTOR>, <ADDRESS>, <FLAGS> )
	
	    descriptor
	        The return value of shmget
	    address
	        if 0, the OS will provide the appropriate address.
	    flags
	        Usually 0, there is one useful flag
		SHM_RDONLY: makes the memory read only.
        
	Ex) shmat( sd, 0, 0 )

12/4
SOTD: Plush - Stone Temple Pilots
Aim: Memes

Shared memory does not only apply to Parent-Child relationships, 
but also applies to any process, as long as the permissions allow.

Shared Memory!
    ftok
        Generate a key for useful for IPC (Interprocess communication) 
	functions.

    ftok( path, x )
    
        path
	    A path to some file, the file must be accessible by the
	    program running.
	    
        x
	    An int

        You could use the header file of the program for the path.
	The generated key will be the same for separate calls.
	
	sd = shmget( ftok("dir/file", 12), 1024, IPC_CREAT | 0644 )

    shmdt
        Detach a variable from a shared memory segment.
	
	Returns 0 upon success or -1 upon failure.
	
	shmdt( pointer )
	
	    pointer
	        The address used to access the segment.

	Example
	    shmdt( p );

    shmctl
        Each shared memory segment has metadata that can be stored in
	a struct (struct smid_ds)
	
	Some of that data can be stored: last access, size, pid of creator,
	pid of last modification
	
	shmctl( descriptor, command, buffer )
	
	    descriptor
	        Return value of shmget
		
	    Commands:
	        IPC_STAT: populate the buffer (struct shmid_ds) with
			  information

	    	IPC_SET: set some of the information from the segment to 
			 the info in buffer

		IPC_RMID: Remove a shared memory segment.

	Example:
	     sd = shmget( key, sizeof(int), 0644 );
	     struct shmid_ds d;
	     shmctl( sd, IPC_STAT, d) ;

12/7
SOTD: The General - Dispatch
Aim: How do we flag down a resource?

Semaphores (created by Edsgar Dijkstra)
    IPC counstruct used to control access to a shared resource (like a
    file or shared memory).
    
    Essentially, a semaphore is a counter that represents how many
    processes can access a resuorce at any given time.
    
	If a semaphore has a value of 3, then it can have 3 active users.
	If a semaphore has a value of 0, then it is unavailable.

    	Semaphore is not attached to the resource in any way. It is only
   	used if your program does so.
	
    Most semaphore operationos are "atomic", meaning they will not be
    split up into multiple processor instructions.
    
    Semaphore operations:
    
        Create a semaphore.
	Set an initial value.
	Up(S) / V(S)
	    Release the semaphore to signal you are done with its
	    associated resource.
	      
	    pseudocode:
	        s++
	Down(S) / P(S)
	    Attempt to take the semaphore.
	    
	    If the semaphore is 0, wait for it to be available.
	    
	    pseudocode:
	        while( s == 0 )
		    block
		s--
	Removing a semaphore

    Semaphore code
        semget - <sys/types.h>, <sys/ipc.h>, <sys/sem.h>
	
	This is not the same as Up(S), the semaphore is not modified by
	semget.
	
	Returns a semaphore descriptor or -1 (errno).
	
	semget( <KEY>, <AMOUNT>, <FLAGS> )
	
	    KEY
	        Unique semaphore identifier (use ftok)
            AAMOUNT
	        Semaphores are actually stored as sets with possibly
		many semaphores stored together. This parameter sets
		the number of semaphores to create/get.
		
            FLAGS
	        Includes permissions for the semaphore
		
		Combine with bitwise or
		
		IPC_CREAT: create the semaphore, will set value to 0.
		IPC_EXCL: Fail if the semaphore already exists and
			  IPC_CREAT is on.

            Example
	        int semd;
		semd = semget( ftok("file/dir", 2), 1), 0644 | IPC_CREAT)

		IPCS - command line utility

12/8
SOTD: TIme is Running Out - Muse
Aim: What's a semaphore? - To control resources!

Semaphore code
    semctl - <sys/types.h> <sys/ipc.h> <sys/sem.h>
    
        Control the semaphore, including:

	    Set the semaphore value
	    Remove the semaphore
	    Get the current value
	    Get information about the semaphore

    semctl( <DESCRIPTOR>, <INDEX>, <OPERATION>, <DATA> )
    
        DESCRIPTOR
	    The return value of semget
	
	INDEX
	    The index of the semaphore you want to control in the
	    semaphore set identified by the descriptor.
	
	OPERATION
	    One of the following constants (there are others as well)
	    
	    IPC_RMID: Remove the semaphore
	    	      If you use this, you will not need <DATA> arg.
	   
	    SETVAL: Set the value. (Requires <DATA>)
	    
	    SETALL: Set the value of every semaphore in the set.
	            (Requires <DATA>)
		    
	    GETALL: Return the value.
	    
	    IPC_STAT: Populate buffer with information about the
	    	      semaphore. (Requires <DATA>)

        DATA
	    Variable for setting/storing information about the
	    semaphore. (Data type: Union semun)

	    EX) union un {
	    	  int i;    //4
		  char c;   //1
		  double d; //8
		};
		
		union un foo;
		foo.i = S;      //sets first four bytes of foo.
		foo.d = 185.36; //sets all 8 bytes of foo, overwriting.
		foo.c = 'c';    //sets first byte as 'c', leaves the rest
		
		Union is only as large as the largest data inside.
		Union is not all of these things at once, it is only
		one of these things.
		
	    You have to declare this union in your main c file on linux
	    machines.
	    
	    union semun {
	        int val;
		struct semid_ds *buf;
		unsigned short  *array;
		struct seminfo  *__buff;
	    };
	          val: used to set initial value
		  buf: buffer for IPC_STAT
int main(int argc, char **argv) {
    
    int key = ftok("makefile", 'b');
    int semid;
   
    if (strcmp( argv[0], "-c" ) == 0 ) {
        semid = semget( key, 1, 0644 | IPC_CREAT);
	union semun su;
	su.val = 3;
	semctl( semid, 0, SETVAL, su );
	printf("semaphore created: %d\n", semid);
    }
    
    if (strcmp( arg[0], "-v" ) == 0) {
        semid == semget( key, 1, 0644 );
	int v;
	v = semctl( semid, 0, GETVAL );
	printf("semaphore value: %d\n", v);
    }
    
    
    if (strcmp( arg[0], "-R" ) == 0) {
        semid == semget( key, 1, 0644 );
	int v = semctl( semid, 0, IPC_RMID );
	printf("semaphore removed\n");
    }
}

12/7
Aim: Turn down or up?

Semaphore Code
    semop
        Perform semaphore operations (like Up/Down)
	
	All operations performed via semop are atomic!
	
	semop <DESCRIPTOR>, <OPERATION>, <AMOUNT>)
	    DESCRIPTOR
	        You know what this is
	    AMOUNT
	        The amount of semaphores you want to operate on in the
		semaphore code
	    	For a single semaphore set, 1
	    OPERATION
	        A pointer to a struct sembuf value
		
		struct sembuf { 
		    short sem_op;
		    short sem_num;
		    short sem_flg;
		};
		
		sem_num
		    The index of the semaphore you want to work on.

		sem_op
		    -1: Down(S);
		     1: Up(S);
		        Any -/+ number will work, you will be requesting
			and releasing that value from the semaphore.
		     0: Block until the semaphore reaches 0.

		sem_flg
		    Provide further options
		    
		    SEM_UNDO: Allow the OS to undo the given operation.
		    	      Useful in the event that a program exits
			      before it could release a semaphore.
		    IPC_NOWAIT: Instead of waiting for the semaphore to
		    		be available, return an error.
                    
		    ex:
			semid = 
			
		        struct sembuf sb;
			sb.sem_num = 0;
			sb.sem_flg = SEM_UNDO;
			sb.sem_op = -1;
			
			semop( semid, &sb );
			
			to release semaphore:
			sem_op = 1;
			semop( semid, &sb );

SOTD: Shinbone Alley/Hard to Exist - Spin Doctors
Aim: Ceci n'est pas une pipe

Pipe
    A conduit between 2 separate processes.

    a ------------> b
    
    Pipes have 2 ends, a read end and a write end.
    
    Pipes are unidirectional (A single pipe must be either read or write
    only in a process).
    
    Pipes act just like files.
    
    You can transfer any data you like through a pipe using read/write.
    
    Unnamed pipes have no external identification (like a descriptor or
    name).
    
    pipe - <unistd.h>
        Create an unnamed pipe.
	
	Returns 0 if the pipe was created, -1 if not.

	Opens both ends of the pipe as files.
	
	pipe( int descriptors[2] )
	
	    descriptors
		Array that will contain the descriptors for each end of
		the array.

int main() {
  int fds[2];
  int f;
  char line[100];
    
  pipe(fds);
  f = fork();
  if (f == 0) {
    close( fd[0] );
    float p = 123.347
    fgets(line, sizeof(line), stdin );
    write( fds[1], line, sizeof(line) );
    close( fds[1] );
  } 
  else {
    close( fd[1] );
    float q;
    read( fds[0], &line, sizeof(line) )
  }
  return 0;
}

You can do this kind of thing with processes in other computers
    
Named Pipes
    Also known as FIFOs.
    
    Same as unnamed pipes except FIFOs have a name that can be used to
    identify them via different programs.
    
    Keep in mind that like unnamed pipes, FIFOs are unidirectonal.
    
    mkfifo
        Shell command to make a FIFO
	$ mkfifo <pipe name>
	
	When you run cat mario, you will need to cat > mario from a
	different terminal.
	
	If you send the end of file signal, it will close the pipe.
	unless there is another cat program open.

12/15
SOTD: Tropicalia - Beck
Aim: A pipe by any other name...

Named Pipes
   
    mkfifo - <sys/types.h> <sys/stat.h>
        
	c function to create a FIFO
	
	Returns 0 on success and -1 on failure (errno)
	
	Once created, the FIFO acts like a regular file, and we can use
	open, read, write, and close on it.

	mkfifo( <name>, <permissions> )
	
	FIFOs will block on open until both ends of the pipe have a
	connection.	

SERVER:

int main() {
  int from_client;
  int e;
  char line[100];
  
  e = mkfifo( "mario", 0644 );
  printf( "<server> pipe created &d\n", e );

  from_client = open( "mario", O_RDONLY ); //This will block the program
  printf( "<server> connection open\n" );

  read( from_client, line, sizeof(line) ); //Blocks for information to
  		     	   		   //be sent.
  printf( "<server> read: [%s]\n", line ); 

  close( from_client );
  return 0;
}

When this is running, you will need to cat > mario in another terminal.

New line is sent in when piping information from the terminal.

Read does not take into account terminating nulls. You should include
terminating nulls if you are sending strings through pipes.

CLIENT:

int main() 
  
  int to_server;
  char line[100];
  
  to_server = open( "mario", O_WRONLY );
  printf( "<client> connection opened\n" );
  remove( "mario" ); //Added to prevent hijackers.

  printf( "<client> enter stuff: " );
  fgets( line, sizeof(line), stdin );

  write( to_server, line, sizeof(line) );
  close( to_server );
  
  return 0;
}

You can hijack the pipe if you run the client multiple times

You can fix it by removing the actual pipe after the connection is
established. --> This is where blocking is helpful.

remove( <PATH> ); --> Removing files.

IF you remake "mario", nothing will conflict. Any new pipe named mario
will be totally separate.

12/16
SOTD: Cantaloop - US3
      (Cantaloupe)
Aim: Always remember to tip your servers

   Server   	     	     Server ---
     ^			       ^       | 7)
 2)  |			       |       v
    ___	    ___		       |      ___
   | W |   |   |	       |     |	 |
1) | K |   | P | 3)   --->     | 6)  | P |
   |_P_|   |___|      	       |     |___|
     ^	     |		       |       |
     | 4)    | 5)	       |       |
   Client <--- 		     Client <---

Server/Client Program Paradigms

    Handshake
        A procedure to ensure that a connection has been established.
	
	Both ends of the connection must verify that they can send and 
	receive data to and from each other.
	
    	Basic Handshake Procedure:
	    1) Server creates a named pipe (Well Known Pipe)
	    2) Server waits for a connection	
	    3) Client creates a "private" pipe
	    4) Client connects to server and sends the private pipe name.
	    5) Client waits for private pipe connection.
	    6) Server receives client's message and removes the WKP.
	    7) Server connects to client pipe, sending an initial
	       acknowledgement message.
	    8) Client receives server's message, removes its private
	       pipe.

Server Program:

int server_handshake( int *from_client ) {
    
    int to_client;
    char buffer[100];
    
    mkfifo( "mario", 0644 );
    *from_client = open( "mario", O_RDONLY );

    read( *from_client, buffer, sizeof(buffer) );
    printf( "<server> connection request: [%s]\n", buffer );    

    remove( "mario" );
    to_client = open( buffer, O_WRONLY );
    write( "message" );
    
    return to_client;
}

int main() {
    
    int to_client;
    int from_client;
    char buffer[100];
     
    while(1) {
      printf("<server> waiting for connection\n" );
      to_client = server_handshake( &from_client );      
      while( read( from_client, buffer, sizeof(buffer) ) ) {
        printf( "<server> received [%s]\n", buffer );
	process( buffer );
	write( to_client, buffer, sizeof(buffer) );
	strncpy( buffer, "", sizeof(buffer) );   
        close( to_client );
      }
    }
    return 0;
}

========================================================================

Client Program:

int client_handshake( int *from_server ) {
  
  int to_server;
  char buffer[100];

  sprintf( buffer, "%d", getpid() ); //prints to buffer.
  mkfifo( buffer, 0644 );

  to_server = open("mario", O_WRONLY );
  write( to_server, buffer, sizeof(buffer) );
  
  *from_server = open( buffer, O_WRONLY );
  remove( buffer );
  
  read( *from_server, buffer, sizeof(buffer) );
  printf( "<client> connection established: [%s]\n", buffer );
  
  return to_server; 
}

int main() 
  int to_server;
  int from_server;
  char buffer[100];
  
  to_server = client_handshake( &from_server );
  
  while (1) {
    printf( "<client> enter stuff: " );
    fgets( buffer, sizeof(buffer), stdin );
    *strchr( buffer, '\n' ) = 0;
    write( to_server, buffer, sizeof(buffer) );
    read( from_server, buffer, sizeof(buffer) );
    printf( "<client> received: [%s]\n", buffer );
  }
  
  close( to_server );
  close( from_server );

  return 0;
}

12/17
SOTD: The Joker - Steve Miller Band
Aim: You just got served!






12/18
SOTD: The last 8 songs on Abbey Road - The Beatles
Aim: Sometimes you have to ask your server for another fork

Basic Server
    1) Basic Handshake
    2) Server gets data from client, "processes" it, and sends back a
       response.
    3) Once the client exits, the server creates a new WKP, removes the
       old client connections, and the steps restart.

Forking Server
    Main server forks off dedicated subservers for each client 
    connection.
    
    Allows for multiple simultaneous clients.
    
    Handshake procedure is modified on the server:
        1 - 6 are the same.

	7) Server forks off a subserver.
	
	8) *Subserver* connects to client pipe, sending an initial
	   acknowledgement message.
	   
	After the handshake:
	
	    Main server creates a new WKP and waits for a new client.
	    
    Central Dispatch Server
        Main server handles all incoming connections.
	
	Subservers are forked off to handle outgoing connections.


SOTD: Paranoid 
