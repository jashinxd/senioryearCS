9/11 - Aim: C what I did there?
Do Now:
From Yesterday:
     4) Figure out what gcc does
     	man gcc
     5) Copy woohoo.c from your home directory to a /code/ directory on homer
        scp woohoo.c jason.shin@homer.stuy.edu:/code
	     ^source      ^destination          ^remote directory
	*Colon is necessary. If you leave out path, file goes to home directory
	*Remote to remote or Remote to current also work

Today:
     List all the Java primitive variable types
     int      32 bit integer
     float    floating point
     boolean  True/False
     char     character
     short    16 bit integer
     double   64 bit floating point
     long     64 bit integer
     byte     8 bit integer
     *bool and byte are not in C

     Last Class Today:
     	  1 student chosen at random everyday. That evening, the person will be
	  responsible for posting notes to Piazza page. Tag the note as "last 
	  class today".
	  	Title the note LCT <MM/DD WEEKDAY>
		For example, LCT 9/10 Thursday

		Also include at the end of the note a link to an interesting 
		piece of tech news.

9/12 - Aim: Variables are the spice of life.
Do Now: What is the smallest variable type that could be used to store the
   following values (using standard sizes)?
   byte (8-bit): 
   	-128 to 127 (or 2^7 to 2^7 - 1)
   short (16-bit):
   	-2^15 to 2^15 - 1
   int (16-bit):
        -2^31 to 2^31 - 1
   long (64-bit):
   	-2^63 to 2^63 - 1
   1) 5 --> byte
   2) -30,000 --> short
   3) 255 --> short
   4) 5,000,000,000 --> long

C Primitive Variable Types
   All C primitives are numeric.
   The only difference is floating point vs. integer and size of variable.
   Size can be platform dependent.
   	sizeof(<TYPE>) can be used to find the size in bytes.
	ex. sizeof(int)
   
   Type		Standard Size (in bytes)
   int		4
   short	2
   long		8
   float	4
   double 	8
   char		1

   All boolean values are numbers
       0 ==> false
       anything else ==> true
       YOU WILL ALL MAKE THIS MISTAKE:
       	   if (x = 6) {...}
       *The assignment value will return the value you are assigning.

9/17
Aim: Always read the fine print.
Do Now: Open up your editor of choice (emacs)
   	Write a basic "Hello World" program in java.

Data Types and Variables
     
     Character literals are single characters inside ''
     	  ex. 'a', '*' ...
     
     String literals exists, even though there is no String data type.
     	  ex. "hello", "you smell"
     
     Variables cannot be declared inside for loops statements, but they can be
     initialized.
     
     Any variable type can be declared an "unsigned" variable
     This signifies the variable will never be negative.
     	  The lower bound of of any unsigned variable is 0
	  The upper bound will be greater than the signed version
	  ex. unsigned char x;
	      0 <= x <= 255

     int main() {    --> You don't need the arguments in main
     	 return 0;   --> Return 0 if everything went ok
     }

     gcc hello.c     --> Generates a program called a.out
     ./a.out	     --> You need the ./ to run it
     gcc hello.c -o greeter
     ./greeter

9/18 - Aim: A vast array of possibilities.
SOTD: Superstitious - Stevie Wonder
Do Now: How do you declare/use arrays in java?
   datatype[] = new datatype[size];
   
   PATH - Location of known executable files
   echo $PATH - Prints out PATH variable in terminal
   which emacs - Prints out path where emacs is
   
   Errors: segmentation fault or a bus fault

   C does not provide any extra functions. You need to include the libraries 
   in order to use the functions in those libraries.
   
   Usual libraries to include
   #include <stdio.h>
   #include <stdlib.h>
   	<> indicates the library is in one of the normal places where C
   	libraries are.

   #include "mylib.h"
   	"" are used for libraries that you wrote.

   printf("bob = %f\n", bob);
   	%f is the placeholder for where bob will appear.
	
   printf() --> function for printing to the screen.
   	f stands for format

	If you want to print variables, you must include formatting placeholders
	in the string argument
	   int i = 5
	   printf("i is %d", i)

	   Type	     Formatting Character
	   int	     %d
	   long	     %ld
	   float     %f
	   double    %lf
	   	     %0
	   char	     %c
	   char array %s
	   pointer    %p

9/22 - Aim: What's the point of it all?
SOTD: Hunger Strike - Temple of the Dog

Memory Management
    Memory allocation either happens at compile time or at run time (dynamic).
    	Ex) using "new" in java was dynamic memory allocation
	Compile Time --> Stack memory
	Run Time --> Heap memory
    Compiler Allocated Memory
    	Packaged with the binary of the program
	*There is no standard default value*
	Variables and arrays are allocated here
	    Ex. float a    int b[5] --> Arrays in C is stack based and cannot
	    	      	       	    	be resized.
*Test your work on lab computers --> They are the middle ground
    Arrays
	Are not dynamic
	Must have a fixed size
	There is no length function
	There is no boundary checking
	    Ex:    bob fred a[0]  a[1]  a[2]  a[3]
	    	   [ ]  [ ]  [ ]   [ ]   [ ] ...
		   992  996  1000

9/22 - Aim: Ok, now we're really going to get to the point
SOTD: Here Comes the Helicopter
   bob fred a[0]  a[1]  a[2]  a[3]
   [7] [86]  [ ]   [ ]   [ ] ...
   992  996  1000
   
   int a[5];
   int fred;
   fred (996) = 86;
   int *pfred

   Variable names are placeholders for memory addresses.

   Pointers - Now the fun really starts
   	Variable that is designed to store memory addresses (think references
	in java)

   & is used to get the memory address of a variable.
     	Ex) &fred
   * is used to declare a variable as a pointer type
        Ex) int *p, double *q, char *r, ...

	  pfred     fred
	  [996] --> [86]
       	  2020	    996
	  
	  *pfred = &fred

   32 Bit Processor vs 64 Bit Processor
      	32 bit can read in 32 bits of memory and 64 bit can read in 64 bits of 
	memory
	32 bit system can only have 2^32 bits of memory, or 4 GB of RAM
	64 bit system can have 2^64 bits of memory

9/28 - Aim: Ok, now we're really goinng to get to the point.
SOTD: Lump - The Presidents of the United States of America

Do Now:
   1) Declare int, double, and char variables.
        int a;
	double b;
	char c;
   2) Declare int, double, and char pointers.
      	int *pa;
	double *pb;
	char *pc;
   3) Initialize each pointer to the address of the corresponding variable.
	pa = &a;
	pb = &b;
	pc = &c;
   4) Print out the pointer's value for each (as an unsigned long)
        printf( pa = %lu\n", *pa);
	printf( pb = %lu\n", *pb);     
	printf( pc = %lu\n", *pc);
   5) 

   Adding 1 to a pointer type will increase the memory address by the amount of 
   bytes of that type.
   Adding a void pointer type adds 1 to memory address
   Pointers - The fun really starts
   
   Variables designed to store memory addresses (think references in java)

       & is used to get the address of the variable
       
       * is used to declare a variable as a pointer type
       	 ex. int *p, double *q, char *r
	 
       Node n;
        n
       [0] --> null

       * is also used as the de-reference operator
            It accesses the value at the memory location stored in a pointer

       All pointer variable types are the same size
       
       Pointer Arithmetic
            int *p = &1;
	    int *c = &i;
	    
	    p++; //will add 4 to p
	    c++; //will add 1 to p

       Array variabes are immutable pointers.

       Pointers can be assigned to array variables
       int ray[5];
       int *rp = ray;

       ray[3] <===> *(rp + 3)
       rp and ray point to ray[0]
       [ ] [ ] [42] [ ]
        0   1   2    3
       a[i] notation is shorthand for *(a+1)
       in fact...
       	  a[i] <===> *(a + 1)
	  i[a] <===> *(i + a)

SOTD: In The Meantime - Spacehog
9/29 - Aim: Time to stop stringing you along.

float fray[5];
float *fp = fray[0]; --> Will try to point to memory address 2.3 (DNE)
      	    	     	 Valid, but you don't mean this.

float *fp = fray; 
      fray--> will point to 824
      	      will print out 824
      *fp --> 2.3, derefernece operator

fray--> [2.3] [ 2 ] [81.7] [.21] [ 5 ]
	 824   828   832    

Value of ray and rp are both the same memory address because they point to the
same thing.
*ray and *rp will dereference what is there and are the same. *ray = ray[0].
&ray and %rp can be different. Usually different from the value of ray and rp
themselves, but can sometimes be the same. 

fp + 2 --> will return 832
*fp + 2 --> will return 4.3 
*(fp + 2) --> will dereference mem address 832 --> 81.7

ray[2] <==> *(ray + 2) <==> *(2 + ray) <==> 2[ray]
Braket notation simply means add these two numbers.

rp++; --> modifying a pointer variable is fine.
ray++; --> ERROR: cannot increment the array variable pointer.

C Strings (ctrings)
    Strings are character arrays that end with a null character (either '' or 0
    or '\0')

    ['c'] ['a'] ['t'] [ 0 ]

    The terminating null character is a convention, string functions will not 
    work without it.

    The following are valid ways to declare strings:
    	char s[256];
	     Normal array declaraction, allocates 256 bytes, nothing is set
	     automatically. Can return junk.
    	char s[256] = "Imagine";
	     Allocates 256 bytes, puts "Imagine" in the first 7 bytes AND adds 
	     a null at the 8th byte. It may still cause a problem if array size
	     is not large enough.
	char s[] = "Tuesday"
	     Allocates 8 bytes, puts "Tuesday" in the first 7 bytes AND adds a
	     null at the 8th bytes.
    *Only time you can directly declare a string to the same char array 
     variable.

SOTD: One Headlight - The Wallflowers
Aim: How to write functioning code

Do Now: Write a c program that does the following
   1) Create a string and set it to some value
   2) Write code to find the length of the string and then print it. (Do not
      write a function for this.)

      char *s = "Mankind";
      Allocates 8 bytes, puts "Mankind" in the first 7 bytes AND adds a null
      at the 8th byte. s is a pointer variable instead of an array.
      *You can now move the pointer of the string. You cannot do that with the
       first 3 ways.

   You can only assign strings with = at declaration.
   char s[] = "zero"; //ok
   s = "seven"; //not ok!

   char *word = "cat";
   char *up = "dog";

   up = "cat"; //Not valid, up will want a single unsigned interger, 
      	       	 NOT another string.
   up = word; //up will now point to "cat". However, we now have a piece of 
      	      //memory that we will not be able to access.
	      //In order to use it, we need to release the memory

int main() {
  char s[] = "RandomStringLOL";
  char *p = s;
  int size = 0;
  /*
  while (*p) {    //--> This works because anything other than 0 is true.
    p++;
    size++;
  }
  */

  while (*p++) { //--> will derederence then add 1
    size++;
  }
  printf("Length of *%s* = %d\n", s, size);
  return 0;
}

C is a procedural function. Order that the functions appear in is important.
  You can make a function header.
      ex) int len(char *s);

SOTD: Tom Sawyer - Rush
Aim: How to write functioning code.
Functions: a brief interlude:
  All C functions are "pass by value"
      A parameter is a copy of the variable passed into the function. The
      original variable is not touched.
      
  ex) void foo(char *s, int i);
      int x = 5;
      char *w = "cool";
      foo(w, x);

       x    w
      [5] [8010]
            '-->[c][o][o][l][0]

      You can change what w points to, but you cannot change its value

  You can put your headers in a header file
  file - stringy.h
  int len(char *s);
  
  Then, in stringy.c, you can
  #include "stringy.h"

Back to Ctrings
     string.h
	C library that includes useful string functions
	All the functions 

	int strcomp( char *s1, char *s2 )
	    Returns 0 if s1 and s2 are identical
	    Returns positive if s1 is greater than s2
	    Returns negative number is s1 is less than s2
	char * strcpy (char *dest, char *source)
	    C
	char * strcat (char *s1, char *s2)
	Appends all the characters i[ 
	   returns s1
	strncat( char s1, char s2, int )
           appends at most n chars from s2 into s1

SOTD: Fake Plastic Trees - Radiohead
Aim: Make it so
char *s1 = "Hello";
char *s2 = "Hello";
char s3[] = "Hello";

"Hello" --> Immutable because it is a string literal
C does not want extra memory. s1, s2, and s3 all point to the same piece
of memory for "Hello"
s1 and s2 are pointers. They will actually POINT to the SAME immutable string
"Hello".
When you declare an array, it will give you a new piece of memory with "Hello"
in it, so you can change it
When including a header file for a library you created for a different main
method, it will return an error.
To get around this, compile them at the same time
gcc main.c stringy.c --> Two main functions! Returns an error.
Just comment out main function in stringy.c, allowing main.c to run.
Having no main functions is also a problem.
