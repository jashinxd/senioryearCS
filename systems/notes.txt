9/11 - Aim: C what I did there?
Do Now:
From Yesterday:
     4) Figure out what gcc does
     	man gcc
     5) Copy woohoo.c from your home directory to a /code/ directory on homer
        scp woohoo.c jason.shin@homer.stuy.edu:/code
	     ^source      ^destination          ^remote directory
	*Colon is necessary. If you leave out path, file goes to home directory
	*Remote to remote or Remote to current also work

Today:
     List all the Java primitive variable types
     int      32 bit integer
     float    floating point
     boolean  True/False
     char     character
     short    16 bit integer
     double   64 bit floating point
     long     64 bit integer
     byte     8 bit integer
     *bool and byte are not in C

     Last Class Today:
     	  1 student chosen at random everyday. That evening, the person will be
	  responsible for posting notes to Piazza page. Tag the note as "last 
	  class today".
	  	Title the note LCT <MM/DD WEEKDAY>
		For example, LCT 9/10 Thursday

		Also include at the end of the note a link to an interesting 
		piece of tech news.

9/12 - Aim: Variables are the spice of life.
Do Now: What is the smallest variable type that could be used to store the
   following values (using standard sizes)?
   byte (8-bit): 
   	-128 to 127 (or 2^7 to 2^7 - 1)
   short (16-bit):
   	-2^15 to 2^15 - 1
   int (16-bit):
        -2^31 to 2^31 - 1
   long (64-bit):
   	-2^63 to 2^63 - 1
   1) 5 --> byte
   2) -30,000 --> short
   3) 255 --> short
   4) 5,000,000,000 --> long

C Primitive Variable Types
   All C primitives are numeric.
   The only difference is floating point vs. integer and size of variable.
   Size can be platform dependent.
   	sizeof(<TYPE>) can be used to find the size in bytes.
	ex. sizeof(int)
   
   Type		Standard Size (in bytes)
   int		4
   short	2
   long		8
   float	4
   double 	8
   char		1

   All boolean values are numbers
       0 ==> false
       anything else ==> true
       YOU WILL ALL MAKE THIS MISTAKE:
       	   if (x = 6) {...}
       *The assignment value will return the value you are assigning.

9/17
Aim: Always read the fine print.
Do Now: Open up your editor of choice (emacs)
   	Write a basic "Hello World" program in java.

Data Types and Variables
     
     Character literals are single characters inside ''
     	  ex. 'a', '*' ...
     
     String literals exists, even though there is no String data type.
     	  ex. "hello", "you smell"
     
     Variables cannot be declared inside for loops statements, but they can be
     initialized.
     
     Any variable type can be declared an "unsigned" variable
     This signifies the variable will never be negative.
     	  The lower bound of of any unsigned variable is 0
	  The upper bound will be greater than the signed version
	  ex. unsigned char x;
	      0 <= x <= 255

     int main() {    --> You don't need the arguments in main
     	 return 0;   --> Return 0 if everything went ok
     }

     gcc hello.c     --> Generates a program called a.out
     ./a.out	     --> You need the ./ to run it
     gcc hello.c -o greeter
     ./greeter

9/18 - Aim: A vast array of possibilities.
SOTD: Superstitious - Stevie Wonder
Do Now: How do you declare/use arrays in java?
   datatype[] = new datatype[size];
   
   PATH - Location of known executable files
   echo $PATH - Prints out PATH variable in terminal
   which emacs - Prints out path where emacs is
   
   Errors: segmentation fault or a bus fault

   C does not provide any extra functions. You need to include the libraries 
   in order to use the functions in those libraries.
   
   Usual libraries to include
   #include <stdio.h>
   #include <stdlib.h>
   	<> indicates the library is in one of the normal places where C
   	libraries are.

   #include "mylib.h"
   	"" are used for libraries that you wrote.

   printf("bob = %f\n", bob);
   	%f is the placeholder for where bob will appear.
	
   printf() --> function for printing to the screen.
   	f stands for format

	If you want to print variables, you must include formatting placeholders
	in the string argument
	   int i = 5
	   printf("i is %d", i)

	   Type	     Formatting Character
	   int	     %d
	   long	     %ld
	   float     %f
	   double    %lf
	   	     %0
	   char	     %c
	   char array %s
	   pointer    %p

9/22 - Aim: What's the point of it all?
SOTD: Hunger Strike - Temple of the Dog

Memory Management
    Memory allocation either happens at compile time or at run time (dynamic).
    	Ex) using "new" in java was dynamic memory allocation
	Compile Time --> Stack memory
	Run Time --> Heap memory
    Compiler Allocated Memory
    	Packaged with the binary of the program
	*There is no standard default value*
	Variables and arrays are allocated here
	    Ex. float a    int b[5] --> Arrays in C is stack based and cannot
	    	      	       	    	be resized.
*Test your work on lab computers --> They are the middle ground
    Arrays
	Are not dynamic
	Must have a fixed size
	There is no length function
	There is no boundary checking
	    Ex:    bob fred a[0]  a[1]  a[2]  a[3]
	    	   [ ]  [ ]  [ ]   [ ]   [ ] ...
		   992  996  1000

9/22 - Aim: Ok, now we're really going to get to the point
SOTD: Here Comes the Helicopter
   bob fred a[0]  a[1]  a[2]  a[3]
   [7] [86]  [ ]   [ ]   [ ] ...
   992  996  1000
   
   int a[5];
   int fred;
   fred (996) = 86;
   int *pfred

   Variable names are placeholders for memory addresses.

   Pointers - Now the fun really starts
   	Variable that is designed to store memory addresses (think references
	in java)

   & is used to get the memory address of a variable.
     	Ex) &fred
   * is used to declare a variable as a pointer type
        Ex) int *p, double *q, char *r, ...

	  pfred     fred
	  [996] --> [86]
       	  2020	    996
	  
	  *pfred = &fred

   32 Bit Processor vs 64 Bit Processor
      	32 bit can read in 32 bits of memory and 64 bit can read in 64 bits of 
	memory
	32 bit system can only have 2^32 bits of memory, or 4 GB of RAM
	64 bit system can have 2^64 bits of memory

9/28 - Aim: Ok, now we're really goinng to get to the point.
SOTD: Lump - The Presidents of the United States of America

Do Now:
   1) Declare int, double, and char variables.
        int a;
	double b;
	char c;
   2) Declare int, double, and char pointers.
      	int *pa;
	double *pb;
	char *pc;
   3) Initialize each pointer to the address of the corresponding variable.
	pa = &a;
	pb = &b;
	pc = &c;
   4) Print out the pointer's value for each (as an unsigned long)
        printf( pa = %lu\n", *pa);
	printf( pb = %lu\n", *pb);     
	printf( pc = %lu\n", *pc);
   5) 

   Adding 1 to a pointer type will increase the memory address by the amount of 
   bytes of that type.
   Adding a void pointer type adds 1 to memory address
   Pointers - The fun really starts
   
   Variables designed to store memory addresses (think references in java)

       & is used to get the address of the variable
       
       * is used to declare a variable as a pointer type
       	 ex. int *p, double *q, char *r
	 
       Node n;
        n
       [0] --> null

       * is also used as the de-reference operator
            It accesses the value at the memory location stored in a pointer

       All pointer variable types are the same size
       
       Pointer Arithmetic
            int *p = &1;
	    int *c = &i;
	    
	    p++; //will add 4 to p
	    c++; //will add 1 to p

       Array variabes are immutable pointers.

       Pointers can be assigned to array variables
       int ray[5];
       int *rp = ray;

       ray[3] <===> *(rp + 3)
       rp and ray point to ray[0]
       [ ] [ ] [42] [ ]
        0   1   2    3
       a[i] notation is shorthand for *(a+1)
       in fact...
       	  a[i] <===> *(a + 1)
	  i[a] <===> *(i + a)

SOTD: In The Meantime - Spacehog
9/29 - Aim: Time to stop stringing you along.

float fray[5];
float *fp = fray[0]; --> Will try to point to memory address 2.3 (DNE)
      	    	     	 Valid, but you don't mean this.

float *fp = fray; 
      fray--> will point to 824
      	      will print out 824
      *fp --> 2.3, derefernece operator

fray--> [2.3] [ 2 ] [81.7] [.21] [ 5 ]
	 824   828   832    

Value of ray and rp are both the same memory address because they point to the
same thing.
*ray and *rp will dereference what is there and are the same. *ray = ray[0].
&ray and %rp can be different. Usually different from the value of ray and rp
themselves, but can sometimes be the same. 

fp + 2 --> will return 832
*fp + 2 --> will return 4.3 
*(fp + 2) --> will dereference mem address 832 --> 81.7

ray[2] <==> *(ray + 2) <==> *(2 + ray) <==> 2[ray]
Braket notation simply means add these two numbers.

rp++; --> modifying a pointer variable is fine.
ray++; --> ERROR: cannot increment the array variable pointer.

C Strings (ctrings)
    Strings are character arrays that end with a null character (either '' or 0
    or '\0')

    ['c'] ['a'] ['t'] [ 0 ]

    The terminating null character is a convention, string functions will not 
    work without it.

    The following are valid ways to declare strings:
    	char s[256];
	     Normal array declaraction, allocates 256 bytes, nothing is set
	     automatically. Can return junk.
    	char s[256] = "Imagine";
	     Allocates 256 bytes, puts "Imagine" in the first 7 bytes AND adds 
	     a null at the 8th byte. It may still cause a problem if array size
	     is not large enough.
	char s[] = "Tuesday"
	     Allocates 8 bytes, puts "Tuesday" in the first 7 bytes AND adds a
	     null at the 8th bytes.
    *Only time you can directly declare a string to the same char array 
     variable.

SOTD: One Headlight - The Wallflowers
Aim: How to write functioning code

Do Now: Write a c program that does the following
   1) Create a string and set it to some value
   2) Write code to find the length of the string and then print it. (Do not
      write a function for this.)

      char *s = "Mankind";
      Allocates 8 bytes, puts "Mankind" in the first 7 bytes AND adds a null
      at the 8th byte. s is a pointer variable instead of an array.
      *You can now move the pointer of the string. You cannot do that with the
       first 3 ways.

   You can only assign strings with = at declaration.
   char s[] = "zero"; //ok
   s = "seven"; //not ok!

   char *word = "cat";
   char *up = "dog";

   up = "cat"; //Not valid, up will want a single unsigned interger, 
      	       	 NOT another string.
   up = word; //up will now point to "cat". However, we now have a piece of 
      	      //memory that we will not be able to access.
	      //In order to use it, we need to release the memory

int main() {
  char s[] = "RandomStringLOL";
  char *p = s;
  int size = 0;
  /*
  while (*p) {    //--> This works because anything other than 0 is true.
    p++;
    size++;
  }
  */

  while (*p++) { //--> will derederence then add 1
    size++;
  }
  printf("Length of *%s* = %d\n", s, size);
  return 0;
}

C is a procedural function. Order that the functions appear in is important.
  You can make a function header.
      ex) int len(char *s);

SOTD: Tom Sawyer - Rush
Aim: How to write functioning code.
Functions: a brief interlude:
  All C functions are "pass by value"
      A parameter is a copy of the variable passed into the function. The
      original variable is not touched.
      
  ex) void foo(char *s, int i);
      int x = 5;
      char *w = "cool";
      foo(w, x);

       x    w
      [5] [8010]
            '-->[c][o][o][l][0]

      You can change what w points to, but you cannot change its value

  You can put your headers in a header file
  file - stringy.h
  int len(char *s);
  
  Then, in stringy.c, you can
  #include "stringy.h"

Back to Ctrings
     string.h
	C library that includes useful string functions
	All the functions 

	int strcomp( char *s1, char *s2 )
	    Returns 0 if s1 and s2 are identical
	    Returns positive if s1 is greater than s2
	    Returns negative number is s1 is less than s2
	char * strcpy (char *dest, char *source)
	    C
	char * strcat (char *s1, char *s2)
	Appends all the characters i[ 
	   returns s1
	strncat( char s1, char s2, int )
           appends at most n chars from s2 into s1

SOTD: Fake Plastic Trees - Radiohead
Aim: Make it so
char *s1 = "Hello";
char *s2 = "Hello";
char s3[] = "Hello";

"Hello" --> Immutable because it is a string literal
C does not want extra memory. s1, s2, and s3 all point to the same piece
of memory for "Hello"
s1 and s2 are pointers. They will actually POINT to the SAME immutable string
"Hello".
When you declare an array, it will give you a new piece of memory with "Hello"
in it, so you can change it
When including a header file for a library you created for a different main
method, it will return an error.
To get around this, compile them at the same time
gcc main.c stringy.c --> Two main functions! Returns an error.
Just comment out main function in stringy.c, allowing main function in  main.c to run.
Having no main functions is also a problem.

SOTD: Rearviewmirror - Pearl Jam
Aim: Make it so

Separate Compilation

    You can combine mutiple C files into a C program by incuding them all in one
    gcc command.
    	ex.
	    gcc test.c string.c foo.c woohoo.c
    You cannot have duplicate function or global variable names across these
    files. This includes the main() function.

    gcc --> Creates an executable file by looking for methods in headers and
    linking them to functions in the standard path. You need to specify where
    the methods in the header function are if they are not in the standard path.
    Will find the main function and link all the functions called in main and
    put them into the executable file.
    If you have multiple main methods, comment one out.

    gcc -c
    	Will compile a c file into a .o file, it is not a fully functional
	program, but it is compiled code. Do this to compile a .c file that does
	not contain a main() function. Will not create an executable file
	
	You can now compile main.c, and then combine with dwstring.o
	gcc main.c dwstring.o

    	__________________________
	V	      |		  V
    dwstring.h    dwstring.c    main.c    
    		      ^	^_______  ^
		      |         | |
		  dwstring.o <---a.out

    Dependency - files that need to be changed because of another changed file.

    Make
	Create compiling instructions and setup dependencies
	Standard name for the file is makefile
	syntax:
	    <TARGET>: <DEPENDENCIES>
	    TAB<RULES>

    makefile
    a.out: dwstring.o main.c
    	    gcc dwstring.o main.o

    dwstring.o: dwstring.c dwstring.h
    	    gcc -c dwstring.c

    main.o: main.c dwstring.h
    	    gcc -c main.o
    First target is always run. The subsequent files will also be checked if
    there are other dependencies. Will recursively check.

SOTD: Breaking the Girl - Red Hot Chili Peppers
Aim: If you can't (al)locate your memory, then... I forget

Dependencies:
dwstring.c    dwstring.h    main.c
        \      /        \   /
       dwstring.o       main.o
       	     \____  _____/
		 a.out

In order to create a.out, you need to combine dwstring.o and main.o
In order to create dwstring.o, you need to combine  dwstring.c and dwstring.h
In order to create main.o, you need to combine dwstring.h and main.c
Think about what files you need in order to create the file you are thinking of
For any particular .o file, you will usually only need one .c file.
Make a dependency chart to put togeter a decent makefile.

make will run a makefile named makefile.
If make is run again without being modified, nothing will happen

    makefile
    all: dwstring.o main.c
    	    gcc -o string_test dwstring.o main.o

    dwstring.o: dwstring.c dwstring.h
    	    gcc -c dwstring.c

    main.o: main.c dwstring.h
    	    gcc -c main.o
    clean:
	    rm *.o
	    rm *~
    run:
	    ./string_test

    First target is always run. The subsequent files will also be checked if
    there are other dependencies. Will recursively check through the
    dependencies.

If you use a name, it will always run.
EX) make all --> will run gcc dwstring.o main.o

You can also specify the target
EX) make dwstring.o

Compares the timestamps of the dependencies and the timestamp of the target.
If timestamp dependency > timestamp target, it will run the rules.

'clean' will never happen untill it is called upon because it has no
dependencies.

'make run' will run the program.

All future assignments will involve a make file.
Don't upload the executable/.o files

Dynamic Memory Allocation:
    malloc(int x)
        Allocates x bytes of memory (from the heap)

	Returns the address at the beginning of the allocation

	Returns a void *, always typecast to the correct pointer type.

        int *p;
	p = (int *)malloc(5 * sizeof(int));
	Will allocate 20 bytes of memory.

	Similar to 'new' in java

    calloc(int n, int x);
        Allocates n * x bytes of memory

	Ensures that each bit is set to 0.

	Works like malloc in all other ways

	int *p;
	p = (int *)calloc(5, sizeof(int));

    realloc(void *p, int x)
    	Changes the amount of memory allocated to a given block.
    
	p must be a pointer to the beginning of an allocated block of memory, 
	but it does not have to be the original pointer
   
	x is the amount of memory reallocated, NOT amount adding/taking away.
 
	If x is smaller than the original size of the allocations, the extra 
	bytes will be released.

    	int *p;
   	p = (int *)malloc(20);
    	p = (int *)realloc(p, 40);

10/9
SOTD: Papa's Got a Brand New Bag - James Brown
Aim: Always structure your code well.

Dynamic Memory Allocation
    Normal memory allocation happens on the stack.
    
    Stack memory gets released as functions pop off.

    Dynamic memory is located on the heap, it persists even after the funtion
    that created it pops off the stack.

    You must manually release dynamically allocated memory from the heap.

    As long a program is running, any memory associated with it will be there.
    When a program ends, memory associated with the program is released.


    free
	Releases dynamically allocated memory.
	
	Takes one parameter, a pointer to the beginning of a dynamically
	allocated block of memory.
	
	Every call to malloc/calloc should have a corresponding call to free.

	int *p;
	p = (int *)malloc(20);
	free(p);

    When you try to change the pointer to the allocated memory, you get an error
    Error is descriptiive because we are requesting memory through the OS.
    Having another pointer point to the beginning is fine.

    Typedef
	Provide a new name for an existing type.
	
	typedef <realtype> <new name>;
	typedef float bubbles;

	Often put in a header files.
	
    	ex: typedef unsigned int size_t;
            size_t x = 139 //x is really an unsigned int

    Struct
	A collection of values in a single data type
	struct {int a; char x;} s;	
	
	To access the data in the struct, you would use the . notation
	ex: struct {int a; char c} s;
	    struct {int a; char c} t;
	    
	    s.a = 97;
	    t.c = '@';

	struct foo {int a; char c};
	struct foo s;
	struct foo t;

	foo is like header, it represents {int a; char c;}
	
	typedef struct n {int a; struct n *next;} node;	
	foo t;
	
	foo *t;
	t = (foo *)malloc( sizeof(foo) );
	
	(*t).a = 97;
	t->a

SOTD: Low Rider - War
Aim: Zelda's in trouble, get Link!
Do Now: What's wrong with this function?
   	(Assume node has been declared correctly)

node * insert_front(node * n, int i) {
     node new;
     new.i = i;
     new.next = n;
     return &new;
}
new is part of stack memory, which would be popped off the stack after the
function called ends. In order to keep the value of node, you would need to
allocate memory on the heap.

It is acceptable to have your function headers lack names for your variables as
long as you have the type.

C - Always use lowercase letters, but separate words by underscores.
print_list - snakecase
printList - camelcase

library.h
#include "link_list.h"
void print_artist(song.node *);

main.c
#include "link_list.h" --> You don't need this because library.h already 
	                   includes it. BUT it does not show that linked_list.h
			   is included if you take it out.
#include "library.h"

# --> pre-processor instruction

#define --> Allows you to create a constant in your code
#define foo 27

#ifndef --> Stands for "if not defined"
#ifndef foo 
#def foo
     <code> 
#endif

#ifndef LINK_LIST_H
#define LINK_LINK_H
typedef struct n {
...
} song_node;
...
#endif
Good convention to do this for all header files to remove conflicts

SOTD: Wheels - Cake
Aim : File this under useful information.
Do Now: What are the different kinds of file permissions?
   	Read	     	 Write	       Execute
Also, who has these permissions?

dev - filled with files with devices.
random in dev --> seeds a random num  generator with random bits in memory.
sranddev() --> seeds using random in dev

File Permissions
     3 Kinds of Permissions
         read, write, execute

     Permissions can be represented as 3 digit binary numbers, or 1 digit octal
     numbers:

     R	    W	   E
     1	    0	   0 => 4 (base 8)
     0	    1 	   0 => 2 (base 8)
     0	    0	   1 => 1 (base 8)
     1	    1	   1 => 7 (base 8)

     There are 3 permission "areas"
     	 user, group, others --> Mutually exclusive sets

 	 each area can have its own permissions:
	 
	 644 => user: read + write, group: read, other: read

     To change the permissions -> chmod 600 foo.
     Owner of the file can ALWAYS  change the permissions of the file.

10/21
Note: Don't compile .h files!
SOTD: Everything - MrNorth
Aim: Opening up a whole new world of possibilities.

     Owner of the file can ALWAYS  change the permissions of the file.

     chown - changes owner of the file.
     chgrp - changes the group of the file.

     File Table
     	 A list of all files used by a program while it is running.
	 
	 Contains basic information like the file's location and size.

	 The file table has a limited size, which is a power of 2 and commonly
	 256, getdtablesize() will return this value. (int) - in <unistd.h>

	 Each file is given an integer index, starting at 0, this is referred
	 to as the file descriptor.

     EX File Table:
         File Descriptor |   Name (path)  | Location | 
	 ---------------------------------------------
		0	 |     stdin	  |	     |
	     	1	 |     stdout	  |	     |
		2	 |     stderr	  |	     |
	 
	 There are 3 files that are always open in the table: 
	     0 or STDIN_FILENO: stdin
	     1 or STDOUT_FILENO: stdout
	     2 or STDERR_FILENO: stderr

open - <fcntl.h>
     Add a file to the file table and returns its file descriptor
     
     If open fails, -1 is returned, extra error information can be found in
     a variable called errno - You need to call <errno.h> to get this.
     
	errno is an int variable that can be found in <errno.h>, using strerror
	(in <string.h>) on errno will return a string description of the error

     open( <PATH>, <FLAGS>, <MODE> )
     
     mode
	Only used when creating a file. Set the new file's permissions using a 3
	digit octal #

	Octal number have a leading 0
	    0644, 0777
	    
     flags
	Determine what you plan to do with the file.
	
	Use the following constants:
	    O_RDONLY
	    O_WRONLY
	    O_RDWR
	    O_APPEND
	    O_TRUNC
	    O_CREAT
	    O_EXCL: When combined with O_CREAT, will return an error if the file
	    	    exists
	All numbers, powers of 2

10/22
SOTD: Fly Me To The Moon - Frank Sinatra
Aim: Read your writes!
     EXLC    TRUNC    CREAT    APPEND    RDWR    WRONLY    RDONLY
     0	     0	      1	       0	 0	 0	   0	--> CREAT
     1	     0	      0	       0	 0	 0	   0	--> EXLC
     0	     0	      0	       0	 0	 1	   0	--> WRONLy
     1	     0	      1	       0	 0	 1	   0	--> ALL OF THESE

     bitwise operators
         &: bitwise and
	 |: bitwise or
	 ~: bitwise not
	 ^: bitwise xor

	 logical operators work on each bit of a value
	 
	 char c = 13;	//00001101
	 char x = ~c; 	//11110010

	 Two's complement
	 
     flags
	 Each flag is a number, to combine flags we use bitwise or
	 
	 O_WRONLY = 1		00000001
	 O_APPEND = 8		00001000
	 O_WRONLY | O_APPEND = 	00001001

     close - <unisrd.h>
     	 Remove a file from the file table
	 
	 Returns a 0 if unsuccessful. Returns -1 amd sets errno if unsuccessful.
	 close( <FILE DESCRIPTOR> );

read - <unistd.h>
     Read in a data from a file

     read( <FILE DESCRIPTOR>, <BUFFER>, <AMOUNT> )
     read(fd, buffer, n)
     
     Read n bytes from the fd's file and put that data into buff.
     
     Returns the number of bytes actually read. Returns -1 and sets errno if
     unsuccessful.

     BUFFER must be a pointer, otherwise it cannot be modified.

write parameters are identical to read parameters.

10/26
SOTD: Crazy - Gnarls Barkley
Aim: Seek and ye shall find

int r
int *s

r (4 bytes)   s (8 bytes)
 [	]       [  0  ] --> [integer]

fd1 = open("goo", O_CREAT, 0666);

There is a umask() function that can shut off permissions
umask(0111); --> This would shut off execute.
default umask is (0022); --> Doesn't allow write and exec for group and others
if umask(0000); --> All permissions will be available.

lseek - <unistd.h>
      Set the current position in an open file
      
      lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )
      
      Offset - How many bytes to move the position by.
      Whence -
      	     Where to measure the offset by
		 
10/28
SOTD: For What It's Worth - Buffalo Springfield
Aim: I need information, stat!
Do Now:
   1) Make a directory
   2) Put a few files in that directory and maybe even a directory or two

   Metadata - Data about data. (i.e last modified, who created it, etc.)

   stat - <sys/stat.h>
       Get information about a file (metadata)
       stat( <PATH TO FILE>, <STAT BUFFER> )
       
       Not an opened file, you don't need a file descriptor
       
           struct stat sb;
      	   stat("foo", &sb);

       to look up man page, use man 2 stat.       

       stat buffer
       	   Must be a pointer to a struct stat
	   
	   All the file information gets put into the stat buffer
	   
	   Some of the fields in the struct stat:
	       st_size
	           file size in bytes
	       st_uid, st_gid
	       	   user id, group id
	       st_mode
	           file permissions    
  	       st_atime, st_mtime
	           last access, last modification
	       
		   These are struct time_t variables. We can use functions
		   in time.h to make sense of them
		   
		   ctime( <struct time_t *> )
		       returns the time as a string
		       
		   time( <struct time_t *> )
		       sets the parameter to the current time

